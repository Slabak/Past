<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>VR Room — Будущее (неон под потолком)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- локальные скрипты -->
  <script src="./assets/js/three.min.js"></script>
  <script src="./assets/js/OrbitControls.js"></script>
  <script src="./assets/js/GLTFLoader.js"></script>

  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    /* XR: чёрный DOM-оверлей (скрыт по умолчанию) */
    #black{position:fixed;inset:0;background:#000;z-index:50;opacity:0;display:none;transition:opacity .7s ease}

    /* загрузка */
    .loading{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;z-index:30}
    .spinner{width:38px;height:38px;border-radius:50%;border:3px solid #333;border-top-color:#fff;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* меню входа */
    .menu{position:fixed;inset:0;background:rgba(0,0,0,.85);display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;z-index:20}
    .menu h1{margin:0 0 8px;font-size:20px;font-weight:600}
    .btn{appearance:none;border:0;padding:12px 16px;border-radius:12px;font-weight:600;cursor:pointer;font-size:15px;background:#14b8a6;color:#00100e;box-shadow:0 4px 20px rgba(0,0,0,.35)}
    .btn.secondary{background:#1f2937;color:#cbd5e1}

    .hud{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.5);padding:8px 10px;border-radius:10px;font-size:13px;z-index:5}
  </style>
</head>
<body>
  <!-- XR DOM overlay -->
  <div id="black"></div>

  <!-- экран загрузки -->
  <div id="loading" class="loading">
    <div class="spinner"></div>
    <div id="loadingText">Загрузка…</div>
  </div>

  <!-- меню -->
  <div id="menu" class="menu">
    <h1>Комната будущего</h1>
    <button id="btnVR" class="btn">Войти в VR</button>
    <button id="btnSpectate" class="btn secondary">Режим наблюдателя</button>
  </div>

  <div class="hud">Подсветка перенесена на потолок: тёплая над кроватью, холодная у терминала.</div>

<script>
/* ===== Настройки ===== */
const PATH  = { models:'./assets/models/', textures:'./assets/textures/' };
const FILES = { model:'future.glb', floor:'floorf.jpg', wall:'wallf.jpg', ceiling:'potolokf.jpg' };
const ROOM  = { size:4, height:3 };

/* неон на потолке — стартовые позиции (правки по месту несложно) */
const BED_NEON_POS  = { x:-0.25, y: ROOM.height - 0.18, z:  0.10 };
const BED_LIGHT_POS = { x:-0.25, y: ROOM.height - 0.12, z:  0.10 };
const BED_NEON_LEN  = 1.05;

const TERM_NEON_POS  = { x:-1.00, y: ROOM.height - 0.18, z: -0.25 };
const TERM_LIGHT_POS = { x:-1.00, y: ROOM.height - 0.12, z: -0.25 };
const TERM_NEON_LEN  = 0.70;

/* ===== Renderer / XR ===== */
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
const isMobile = /Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);
renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
if (renderer.xr.setFoveation) renderer.xr.setFoveation(1.0);
document.body.appendChild(renderer.domElement);

/* ===== Scene / Camera ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x05070d);
scene.fog = new THREE.Fog(0x05070d, 5.5, 12);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 1.6, ROOM.size * 0.45);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enabled = false;
controls.target.set(0, 1.6, 0);

/* ===== Свет (база) ===== */
scene.add(new THREE.HemisphereLight(0x91a4ff, 0x0a0d16, 0.45));
const key = new THREE.DirectionalLight(0xffffff, 0.38);
key.position.set(-1.6, 3.6, 1.4);
key.castShadow = true;
key.shadow.mapSize.set(1024,1024);
key.shadow.camera.near = 0.1; key.shadow.camera.far = 10;
key.shadow.bias = -0.0006; key.shadow.normalBias = 0.02;
scene.add(key);

const fill = new THREE.PointLight(0x00e5ff, 0.6, 6.0); fill.position.set(-1.8, 1.2, -1.6); scene.add(fill);
const rim  = new THREE.PointLight(0xff3ea5, 0.35, 6.0); rim.position.set( 1.4, 2.2,  0.8); scene.add(rim);

/* ===== Текстуры пола/стен/потолка ===== */
const texLoader = new THREE.TextureLoader();
const ANISO = 4;
const setSRGB = t => (t && ('colorSpace' in t) ? (t.colorSpace=THREE.SRGBColorSpace,t): (t.encoding=THREE.sRGBEncoding,t));
const loadT = url => { const t = texLoader.load(url); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.anisotropy=ANISO; return setSRGB(t); };

const tFloor = loadT(PATH.textures + FILES.floor);   tFloor.repeat.set(1.3,1.3);
const tWall  = loadT(PATH.textures + FILES.wall );   tWall.repeat.set(1.2,1.0);
const tCeil  = loadT(PATH.textures + FILES.ceiling); tCeil.repeat.set(1.2,1.2);

/* ===== Комната ===== */
{ const g=new THREE.PlaneGeometry(ROOM.size, ROOM.size);
  const m=new THREE.MeshStandardMaterial({ map:tFloor, color:0x1c2126, roughness:0.95, metalness:0 });
  const mesh=new THREE.Mesh(g,m); mesh.rotation.x=-Math.PI/2; mesh.receiveShadow=true; scene.add(mesh); }
{ const g=new THREE.PlaneGeometry(ROOM.size, ROOM.size);
  const m=new THREE.MeshStandardMaterial({ map:tCeil, color:0x0c0f14, roughness:0.98, metalness:0 });
  const ceil=new THREE.Mesh(g,m); ceil.rotation.x=Math.PI/2; ceil.position.y=ROOM.height; scene.add(ceil); }
{ const g=new THREE.PlaneGeometry(ROOM.size, ROOM.height);
  const m=new THREE.MeshStandardMaterial({ map:tWall, color:0x101217, roughness:0.98, metalness:0 });
  [
    {pos:[0,ROOM.height/2,-ROOM.size/2], rot:[0,0,0]},
    {pos:[0,ROOM.height/2, ROOM.size/2], rot:[0,Math.PI,0]},
    {pos:[-ROOM.size/2,ROOM.height/2,0], rot:[0, Math.PI/2, 0]},
    {pos:[ ROOM.size/2,ROOM.height/2,0], rot:[0,-Math.PI/2, 0]},
  ].forEach(s=>{ const w=new THREE.Mesh(g,m); w.position.set(...s.pos); w.rotation.set(...s.rot); w.receiveShadow=true; scene.add(w); });
}

/* ===== Утилита: неоновая планка ===== */
function addNeonBar({x=0,y=1.2,z=0,len=1.6,rotY=0,color=0xff7a50,intensity=2.4,thickness=0.045}={}){
  const geom=new THREE.BoxGeometry(len, thickness, 0.02);
  const mat=new THREE.MeshStandardMaterial({
    color:0x141414,
    emissive: color,
    emissiveIntensity: intensity,
    roughness:0.35,
    metalness:0.02
  });
  const bar=new THREE.Mesh(geom,mat);
  bar.position.set(x,y,z); bar.rotation.y=rotY; bar.castShadow=false; bar.receiveShadow=false;
  scene.add(bar);
  return bar;
}

/* ===== Неоны на потолке + реальные источники ===== */
const bedBar   = addNeonBar({ x:BED_NEON_POS.x,  y:BED_NEON_POS.y,  z:BED_NEON_POS.z,  len:BED_NEON_LEN,  rotY:0,          color:0xff7a50, intensity:2.6, thickness:0.05 });
const bedLight = new THREE.PointLight(0xff7a50, 1.4, 3.8, 2.0);
bedLight.position.set(BED_LIGHT_POS.x, BED_LIGHT_POS.y, BED_LIGHT_POS.z); scene.add(bedLight);

const termBar   = addNeonBar({ x:TERM_NEON_POS.x, y:TERM_NEON_POS.y, z:TERM_NEON_POS.z, len:TERM_NEON_LEN, rotY:Math.PI/2, color:0x9ffcff, intensity:2.0, thickness:0.04 });
const termLight = new THREE.PointLight(0x9ffcff, 1.1, 3.4, 2.0);
termLight.position.set(TERM_LIGHT_POS.x, TERM_LIGHT_POS.y, TERM_LIGHT_POS.z); scene.add(termLight);

/* «ореола» на потолке — мягкие пятна под неонами */
function ceilingHalo(x, z, w, color, op=0.28){
  const g = new THREE.PlaneGeometry(w, 0.22);
  const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:op, blending:THREE.AdditiveBlending, depthWrite:false });
  const halo = new THREE.Mesh(g, m);
  halo.position.set(x, ROOM.height - 0.01, z);
  halo.rotation.x = 0; // параллельно потолку
  scene.add(halo);
  return halo;
}
ceilingHalo(BED_NEON_POS.x,  BED_NEON_POS.z,  BED_NEON_LEN*0.95, 0xffb08a, 0.24);
ceilingHalo(TERM_NEON_POS.x, TERM_NEON_POS.z, TERM_NEON_LEN*0.95, 0x9ffcff, 0.20);

/* ===== Загрузка будущего (GLB) ===== */
const loadingEl   = document.getElementById('loading');
const loadingText = document.getElementById('loadingText');
const menuEl      = document.getElementById('menu');
const blackEl     = document.getElementById('black');

const manager = new THREE.LoadingManager();
manager.onStart    = ()=>{ loadingText.textContent = 'Загрузка…'; };
manager.onProgress = (url, loaded, total)=>{ loadingText.textContent = `Загрузка… ${loaded}/${total}`; };
manager.onLoad     = ()=>{ loadingEl.style.display='none'; menuEl.style.display='flex'; };
manager.onError    = (url)=>{ loadingText.textContent = `Ошибка: ${url}`; };

new THREE.GLTFLoader(manager).load(PATH.models + FILES.model, (g)=>{
  const obj = g.scene;
  obj.traverse(n=>{ if(n.isMesh){ n.castShadow = true; n.receiveShadow = true; }});
  scene.add(obj);
  renderer.compile(scene, camera);
});

/* ===== XR helper: анти «чёрный старт» ===== */
function showBlack(){ blackEl.style.display='block'; requestAnimationFrame(()=>{ blackEl.style.opacity='1'; }); }
function hideBlack(){ blackEl.style.opacity='0'; setTimeout(()=>{ blackEl.style.display='none'; }, 750); }
function waitXRFrames(session, n, cb){
  let i=0; function onF(){ if(++i>=n) cb(); else session.requestAnimationFrame(onF); }
  session.requestAnimationFrame(onF);
}
async function startXR(){
  if (!navigator.xr) { alert('WebXR не поддерживается. Открой в Quest Browser.'); return; }
  try{
    renderer.render(scene, camera); // прогрев перед VR
    showBlack();

    const session = await navigator.xr.requestSession('immersive-vr', { requiredFeatures:['local-floor'], optionalFeatures:['bounded-floor'] });
    await renderer.xr.setSession(session);

    const onVis = ()=>{
      if (session.visibilityState === 'visible'){ waitXRFrames(session, 2, hideBlack); }
      else showBlack();
    };
    session.addEventListener('visibilitychange', onVis);
    onVis();

    session.addEventListener('end', ()=>{ showBlack(); menuEl.style.display='flex'; });
  } catch (e) { console.error(e); alert('Не удалось запустить VR-сессию.'); }
}

/* ===== UI ===== */
document.getElementById('btnVR').onclick = async ()=>{ menuEl.style.display='none'; await startXR(); };
document.getElementById('btnSpectate').onclick = ()=>{ menuEl.style.display='none'; controls.enabled=true; showBlack(); setTimeout(hideBlack,150); };

/* ===== Resize / Loop ===== */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
renderer.setAnimationLoop(()=>{
  if (controls.enabled) controls.update();
  renderer.render(scene, camera);
});
</script>
</body>
</html>
