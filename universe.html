<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Тессеракт — хранитель времени</title>

<!-- локальные three -->
<script src="./assets/js/three.min.js"></script>
<script src="./assets/js/OrbitControls.js"></script>

<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:30;flex-direction:column;gap:10px}
  .bar{width:240px;height:6px;background:#222;border-radius:6px;overflow:hidden}
  .bar>i{display:block;height:100%;width:0;background:#14b8a6}
  .menu{position:fixed;inset:0;background:rgba(0,0,0,.88);display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;z-index:20}
  .btn{appearance:none;border:0;padding:12px 16px;border-radius:12px;font-weight:600;cursor:pointer;font-size:15px;background:#14b8a6;color:#00100e;box-shadow:0 4px 20px rgba(0,0,0,.35)}
  .btn.secondary{background:#1f2937;color:#cbd5e1}
  .hud{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:13px;z-index:5}
</style>
</head>
<body>
  <div id="loading" class="loading">
    <div>Собираю «книжный тессеракт»…</div>
    <div class="bar"><i id="bar"></i></div>
  </div>

  <div id="menu" class="menu">
    <button id="btnVR" class="btn">Войти в VR</button>
    <button id="btnSpectate" class="btn secondary">Режим наблюдателя</button>
  </div>

  <div class="hud">Смотри вокруг. В «швах» мигают ваши кадры: прошлое → настоящее. Лёгкое движение — это «поток времени».</div>

<script>
/* ================== загрузчик ================== */
const manager = new THREE.LoadingManager();
manager.onProgress = (_url, loaded, total)=>{ document.getElementById('bar').style.width = ((loaded/total)*100|0)+'%'; };
manager.onLoad = ()=>{ document.getElementById('loading').style.display='none'; document.getElementById('menu').style.display='flex'; };
manager.onError = ()=>{ document.getElementById('loading').style.display='none'; document.getElementById('menu').style.display='flex'; };

const texLoader = new THREE.TextureLoader(manager);

/* ================== renderer/camera/scene ================== */
const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
const isMobile = /Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);
renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 200);
camera.position.set(0,1.6,0.01);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enabled = false; controls.target.set(0,1.6,0);

/* ================== fade overlay (устойчиво для XR) ================== */
function makeFade(){
  const g=new THREE.PlaneGeometry(2,2);
  const m=new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:1,depthTest:false});
  const q=new THREE.Mesh(g,m); q.renderOrder=9999; q.position.z=-0.3;
  camera.add(q); scene.add(camera);
  return { show:()=>m.opacity=1, fade:(ms=700)=>{const t0=performance.now();(function f(t){const k=Math.min(1,(t-t0)/ms);m.opacity=1-k;if(k<1)requestAnimationFrame(f)})(t0)} };
}
const screen = makeFade();

function waitXRFrames(n=3){return new Promise(res=>{let left=n; function tick(){left--; if(left<=0) res(); else requestAnimationFrame(tick);} requestAnimationFrame(tick);});}

/* ================== атмосфера: лёгкий туман/неон ================== */
const hemi = new THREE.HemisphereLight(0x88aaff, 0x000010, 0.15); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.18); dir.position.set(3,6,-2); scene.add(dir);

/* ================== решётка (инстансы) ================== */
const lattice = new THREE.Group(); scene.add(lattice);

// материалы «дерево/медь»
const matX = new THREE.MeshStandardMaterial({color:0x3a2c1f, roughness:0.9, metalness:0.15});
const matY = new THREE.MeshStandardMaterial({color:0x231a12, roughness:0.95, metalness:0.12});
const matZ = new THREE.MeshStandardMaterial({color:0x2e2218, roughness:0.92, metalness:0.18});

// базовые «рейки»
const barGeo = new THREE.BoxGeometry(1, 0.04, 0.04); // X-рейка; будем масштабировать при инстансинге

function makeRods(size=6, cell=1.2){
  // Кубическая сетка NxNxN вокруг (0,1.6,0)
  const half = (size-1)/2;
  const countPerAxis = size*size; // по каждой ориентации
  const rodsX = new THREE.InstancedMesh(barGeo, matX, countPerAxis);
  const rodsY = new THREE.InstancedMesh(barGeo, matY, countPerAxis);
  const rodsZ = new THREE.InstancedMesh(barGeo, matZ, countPerAxis);
  rodsX.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  rodsY.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  rodsZ.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

  const m = new THREE.Matrix4();
  let i=0;
  for(let y=0;y<size;y++){
    for(let z=0;z<size;z++){
      const wy = (y-half)*cell + 1.6; // центр по глазам
      const wz = (z-half)*cell;
      // X ориентация — длинная
      m.identity().makeScale(cell,1,1).setPosition(0,wy,wz);
      rodsX.setMatrixAt(i++, m);
    }
  }
  i=0;
  for(let x=0;x<size;x++){
    for(let z=0;z<size;z++){
      const wx = (x-half)*cell;
      const wz = (z-half)*cell;
      // Y ориентация
      m.identity().makeScale(1,cell,1).setPosition(wx,1.6,wz);
      rodsY.setMatrixAt(i++, m);
    }
  }
  i=0;
  for(let x=0;x<size;x++){
    for(let y=0;y<size;y++){
      const wx = (x-half)*cell;
      const wy = (y-half)*cell + 1.6;
      // Z ориентация
      m.identity().makeScale(1,1,cell).setPosition(wx,wy,0);
      rodsZ.setMatrixAt(i++, m);
    }
  }

  lattice.add(rodsX, rodsY, rodsZ);
}
makeRods(7, 1.05); // плотность/размер клетки: можно крутить

/* ================== «поток времени» — полосы света ================== */
const streakGeo = new THREE.PlaneGeometry(0.015, 0.9);
const streakMat = new THREE.MeshBasicMaterial({color:0x9be8ff, transparent:true, opacity:0.22, depthWrite:false, blending:THREE.AdditiveBlending});
const streaks = new THREE.Group(); lattice.add(streaks);
for(let i=0;i<220;i++){
  const s = new THREE.Mesh(streakGeo, streakMat.clone());
  s.material.opacity = 0.12 + Math.random()*0.2;
  s.position.set( (Math.random()-0.5)*6, 0.6+Math.random()*2.2, (Math.random()-0.5)*6 );
  s.rotation.y = Math.random()*Math.PI;
  streaks.add(s);
}

/* ================== ФОТО — «швы времени» ================== */
const photosGroup = new THREE.Group(); lattice.add(photosGroup);

// соберём список файлов фоток (0.jpg..9.jpg). Просто пытаемся загрузить подряд.
const photoTextures = [];
for(let i=0;i<16;i++){
  const url = `./assets/textures/photos/${i}.jpg`;
  photoTextures.push(texLoader.load(url, t=>{ t.colorSpace = THREE.SRGBColorSpace; }));
}

// создаём «оконца» между рейками
function makePhotoSlots(){
  const MAX = 18; // сколько увидеть одновременно
  const slotGeo = new THREE.PlaneGeometry(0.52, 0.32);
  for(let i=0;i<MAX;i++){
    const tex = photoTextures[i % photoTextures.length];
    const mat = new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:0});
    const m = new THREE.Mesh(slotGeo, mat);
    // позиция: случайная грань клетки
    const side = Math.floor(Math.random()*3); // 0-x,1-y,2-z
    const s = 3.0; // радиус
    if(side===0){ // смотрит +/-X
      m.position.set( Math.random()<.5? -s:s, 1.0+Math.random()*1.6, (Math.random()-0.5)*2.6 );
      m.rotation.y = (Math.random()<.5? Math.PI/2 : -Math.PI/2);
    }else if(side===1){ // +/-Y (потолок/пол)
      m.position.set( (Math.random()-0.5)*2.6, Math.random()<.5? (1.6-1.4):(1.6+1.4), (Math.random()-0.5)*2.6 );
      m.rotation.x = (Math.random()<.5? Math.PI/2 : -Math.PI/2);
    }else{ // +/-Z
      m.position.set( (Math.random()-0.5)*2.6, 1.0+Math.random()*1.6, Math.random()<.5? -s:s );
      m.rotation.y = (Math.random()<.5? 0 : Math.PI);
    }
    m.userData.t0 = Math.random()*6; // фазы мигания
    photosGroup.add(m);
  }
}
makePhotoSlots();

/* ================== движение и анимации ================== */
const flow = { z: 0.25 }; // скорость «потока»
let lastT = performance.now()*0.001;

function animate(){
  const t = performance.now()*0.001;
  const dt = Math.min(0.033, t-lastT); lastT = t;

  // мир едет очень медленно вперёд (в XR кажется, что «тянет пространство»)
  lattice.position.z += dt * flow.z;
  if (lattice.position.z > 1.05) lattice.position.z = 0;

  // лёгкая пульсация неона у полос
  streaks.children.forEach((s,idx)=>{
    s.material.opacity = 0.08 + 0.12*Math.sin(t*1.5 + idx*0.37)**2;
  });

  // фото: циклическое появление/затухание
  photosGroup.children.forEach((m,idx)=>{
    const tt = (t + m.userData.t0) % 8.0; // цикл 8с
    const fadeIn = THREE.MathUtils.clamp((tt-0.5)/1.0, 0,1);
    const hold   = THREE.MathUtils.clamp((tt-1.5)/3.5, 0,1);
    const fadeOut= THREE.MathUtils.clamp((tt-5.2)/1.2, 0,1);
    m.material.opacity = fadeIn*(1-fadeOut)*0.95;
  });

  renderer.render(scene,camera);
}

/* ================== XR измеренный фейд ================== */
renderer.xr.addEventListener('sessionstart', async ()=>{
  controls.enabled = false; screen.show();
  await waitXRFrames(3);
  screen.fade(700);
});

/* ================== UI ================== */
const loading = document.getElementById('loading');
const menu = document.getElementById('menu');
document.getElementById('btnVR').onclick = async ()=>{
  menu.style.display='none'; screen.show(); await startXR();
};
document.getElementById('btnSpectate').onclick = ()=>{
  menu.style.display='none'; controls.enabled=true; screen.show(); setTimeout(()=>screen.fade(700),150);
};

/* ================== main loop ================== */
renderer.setAnimationLoop(()=>{ animate(); if (controls.enabled) controls.update(); });

/* ================== XR start ================== */
async function startXR(){
  if (!navigator.xr){ alert('WebXR не поддерживается. Открой в Quest Browser.'); return; }
  try{
    const s = await navigator.xr.requestSession('immersive-vr', { optionalFeatures:['local-floor','bounded-floor'] });
    await renderer.xr.setSession(s);
  }catch(e){ console.error(e); alert('Не удалось запустить VR-сессию.'); }
}

/* ================== resize ================== */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ================== старт загрузки фоток ================== */
// если фоток нет — менеджер всё равно отпустит меню после onError/onLoad
</script>
</body>
</html>
