<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>–¢–µ—Å—Å–µ—Ä–∞–∫—Ç ‚Äî low, XR —Å—Ç–∞—Ä—Ç –±–µ–∑ —á—ë—Ä–Ω–æ–≥–æ</title>
<script src="./assets/js/three.min.js"></script>
<script src="./assets/js/OrbitControls.js"></script>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #black{position:fixed;inset:0;background:#000;z-index:50;opacity:1;transition:opacity .7s ease}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:40}
  .menu{position:fixed;inset:0;background:rgba(0,0,0,.88);display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;z-index:30}
  .btn{appearance:none;border:0;padding:12px 16px;border-radius:12px;font-weight:600;cursor:pointer;font-size:15px;background:#14b8a6;color:#00100e;box-shadow:0 4px 20px rgba(0,0,0,.35)}
  .btn.secondary{background:#1f2937;color:#cbd5e1}
  .hud{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:13px;z-index:5}
  .mute{position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2);padding:8px 10px;border-radius:10px;font-size:13px;z-index:6;cursor:pointer}
</style>
</head>
<body>
  <div id="black"></div>
  <div id="loading" class="overlay"><div>–°–æ–±–∏—Ä–∞—é —Ç–µ—Å—Å–µ—Ä–∞–∫—Ç‚Ä¶</div></div>
  <div id="menu" class="menu">
    <button id="btnVR" class="btn">–í–æ–π—Ç–∏ –≤ VR</button>
    <button id="btnSpectate" class="btn secondary">–†–µ–∂–∏–º –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è</button>
  </div>
  <div class="hud">–ü–ö: –º—ã—à—å ‚Äî –æ–±–∑–æ—Ä. –ö–ª–∏–∫ –≤–∫–ª—é—á–∞–µ—Ç –º—É–∑—ã–∫—É. –ö–∞–º–µ—Ä–∞ –Ω–µ —Ç—Ä—è—Å—ë—Ç—Å—è.</div>
  <button id="mute" class="mute">üîä –ú—É–∑—ã–∫–∞</button>

<script>
/* ---------- –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ---------- */
const PHOTO_FILES = Array.from({length:15}, (_,i)=>`./assets/textures/${i+1}.jpg`);
const GRID_COUNT = 4;            // 4 –∫—É–±–∞ –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã, —Ñ–∏–∫—Å low
const PHOTO_SIZE = 1.05;
const PHOTO_NEAR = 2.0;
const PHOTO_POOL = 18;
const PHOTO_OPACITY_MAX = 0.65;
const PHOTO_LIFETIME = [1.8, 3.2];
const PHOTO_COOLDOWN = [1.2, 2.2];
const PHOTO_RANGE = [0.65, 0.9];

const ua = navigator.userAgent;
const isQuest  = /Quest|Oculus/i.test(ua);
const isMobile = /Android|iPhone|iPad|iPod|Quest|Oculus/i.test(ua);

const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
if (renderer.xr.setReferenceSpaceType) renderer.xr.setReferenceSpaceType('local-floor');
if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.52;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
if (!isQuest) scene.fog = new THREE.FogExp2(0x000000, 0.022);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 2000);
camera.position.set(0,1.6,0.01);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enabled = false; controls.target.set(0,1.6,0);

/* -------- —Å–≤–µ—Ç -------- */
scene.add(new THREE.AmbientLight(0x120e0b, 0.95));
const key = new THREE.DirectionalLight(0xffe0b5, 0.58); key.position.set(-2.5,5,-4.5); scene.add(key);
const rim = new THREE.DirectionalLight(0xbfd4ff, 0.18);  rim.position.set( 3.0,2.0, 3.5); scene.add(rim);

/* -------- –º–∞—Ç–µ—Ä–∏–∞–ª—ã -------- */
const matWood  = new THREE.MeshLambertMaterial({color: 0x3c2f24});
const matGlass = new THREE.MeshLambertMaterial({color: 0xcfd9ff, transparent:true, opacity:0.30});
const matGlow  = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, depthWrite:false});

/* -------- –ø–∞—Ä–∞–º–µ—Ç—Ä—ã fixed low -------- */
function qualityParams(){
  return {cell:3, count:GRID_COUNT, beam:0.085, slat:0.024, distance:3.6, glassRatio:0.3, fillDensity:5, glowCount:160, layers:2};
}

/* -------- –±–æ–∫–µ-—Ç–µ–∫—Å—Ç—É—Ä–∞ -------- */
function makeBokehTexture(){
  const s=256, c=document.createElement('canvas'); c.width=c.height=s; const ctx=c.getContext('2d');
  const g=ctx.createRadialGradient(s/2,s/2,0, s/2,s/2,s/2);
  g.addColorStop(0,'rgba(255,255,255,0.9)');
  g.addColorStop(0.6,'rgba(255,255,255,0.25)');
  g.addColorStop(1,'rgba(255,255,255,0.0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
  const t=new THREE.CanvasTexture(c); t.generateMipmaps=false; t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter;
  if ('colorSpace' in t) t.colorSpace = THREE.SRGBColorSpace; else t.encoding = THREE.sRGBEncoding;
  return t;
}
const bokehTex = makeBokehTexture(); /* <-- –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ */

/* -------- —Å–ª–æ–π —Ç–µ—Å—Å–µ—Ä–∞–∫—Ç–∞ -------- */
function buildTesseractLayer(p, phase=0, tint=1.0){
  const {cell,beam,slat,distance,fillDensity,glowCount} = p;
  const group = new THREE.Group();

  const half = cell/2, steps=fillDensity, step=cell/(steps+1);
  const geoX = new THREE.BoxGeometry(cell, beam, beam);
  const geoY = new THREE.BoxGeometry(beam, cell, beam);
  const geoZ = new THREE.BoxGeometry(beam, beam, cell);
  const geoLX= new THREE.BoxGeometry(cell, slat, slat);
  const geoLY= new THREE.BoxGeometry(slat, cell, slat);
  const geoLZ= new THREE.BoxGeometry(slat, slat, cell);
  const geoGlow = new THREE.PlaneGeometry(0.3, 1.2);

  let nFX=0,nFY=0,nFZ=0,nLX=0,nLY=0,nLZ=0,nIF=0;
  const innerFrameOffsets=[-cell/3,cell/3];

  for(let ix=-GRID_COUNT; ix<=GRID_COUNT; ix++)
  for(let iy=-GRID_COUNT; iy<=GRID_COUNT; iy++)
  for(let iz=-GRID_COUNT; iz<=GRID_COUNT; iz++){
    const cx=ix*cell, cy=1.6+iy*cell, cz=iz*cell;
    if (Math.hypot(cx,cy-1.6,cz) < distance + cell*0.5) continue;
    nFX+=4; nFY+=4; nFZ+=4;
    nLX+=Math.max(0,(steps-1))*2;
    nLY+=Math.max(0,(steps-1))*2;
    nLZ+=Math.max(0,(steps-1))*2;
    nIF+=innerFrameOffsets.length*12;
  }

  const frameX=new THREE.InstancedMesh(geoX, matWood.clone(), nFX);
  const frameY=new THREE.InstancedMesh(geoY, matWood.clone(), nFY);
  const frameZ=new THREE.InstancedMesh(geoZ, matWood.clone(), nFZ);
  const lineX =new THREE.InstancedMesh(geoLX, matWood.clone(), nLX);
  const lineY =new THREE.InstancedMesh(geoLY, matWood.clone(), nLY);
  const lineZ =new THREE.InstancedMesh(geoLZ, matWood.clone(), nLZ);
  const iFrame=new THREE.InstancedMesh(new THREE.BoxGeometry(cell, beam*0.7, beam*0.7), matGlass.clone(), nIF);

  const layerMult = tint;
  [frameX,frameY,frameZ,lineX,lineY,lineZ].forEach(im=>im.material.color.multiplyScalar(layerMult));
  iFrame.material.opacity*=0.9*layerMult;

  const M = new THREE.Matrix4();
  let ixF=0,iyF=0,izF=0, ixL=0,iyL=0,izL=0, iIF=0;

  for(let ix=-GRID_COUNT; ix<=GRID_COUNT; ix++)
  for(let iy=-GRID_COUNT; iy<=GRID_COUNT; iy++)
  for(let iz=-GRID_COUNT; iz<=GRID_COUNT; iz++){
    const cx=ix*cell, cy=1.6+iy*cell, cz=iz*cell;
    if (Math.hypot(cx,cy-1.6,cz) < distance + cell*0.5) continue;

    M.identity().setPosition(cx, cy - half, cz - half); frameX.setMatrixAt(ixF++, M);
    M.identity().setPosition(cx, cy - half, cz + half); frameX.setMatrixAt(ixF++, M);
    M.identity().setPosition(cx, cy + half, cz - half); frameX.setMatrixAt(ixF++, M);
    M.identity().setPosition(cx, cy + half, cz + half); frameX.setMatrixAt(ixF++, M);

    M.identity().setPosition(cx - half, cy, cz - half); frameY.setMatrixAt(iyF++, M);
    M.identity().setPosition(cx + half, cy, cz - half); frameY.setMatrixAt(iyF++, M);
    M.identity().setPosition(cx - half, cy, cz + half); frameY.setMatrixAt(iyF++, M);
    M.identity().setPosition(cx + half, cy, cz + half); frameY.setMatrixAt(iyF++, M);

    M.identity().setPosition(cx - half, cy - half, cz); frameZ.setMatrixAt(izF++, M);
    M.identity().setPosition(cx + half, cy - half, cz); frameZ.setMatrixAt(izF++, M);
    M.identity().setPosition(cx - half, cy + half, cz); frameZ.setMatrixAt(izF++, M);
    M.identity().setPosition(cx + half, cy + half, cz); frameZ.setMatrixAt(izF++, M);

    for(let i=1;i<=steps;i++){
      const d=-half + i*step; if (Math.abs(d)<=0.001) continue;
      M.identity().setPosition(cx, cy, cz + d); lineX.setMatrixAt(ixL++, M);
      M.identity().setPosition(cx, cy, cz - d); lineX.setMatrixAt(ixL++, M);
      M.identity().setPosition(cx, cy + d, cz); lineZ.setMatrixAt(izL++, M);
      M.identity().setPosition(cx, cy - d, cz); lineZ.setMatrixAt(izL++, M);
      M.identity().setPosition(cx + d, cy, cz); lineY.setMatrixAt(iyL++, M);
      M.identity().setPosition(cx - d, cy, cz); lineY.setMatrixAt(iyL++, M);
    }

    for(const off of [-cell/3,cell/3]){
      M.identity().setPosition(cx, cy - half, cz + off); iFrame.setMatrixAt(iIF++, M);
      M.identity().setPosition(cx, cy + half, cz + off); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationZ(Math.PI/2).setPosition(cx - half, cy, cz + off); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationZ(Math.PI/2).setPosition(cx + half, cy, cz + off); iFrame.setMatrixAt(iIF++, M);

      M.identity().setPosition(cx, cy + off, cz - half); iFrame.setMatrixAt(iIF++, M);
      M.identity().setPosition(cx, cy + off, cz + half); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx - half, cy + off, cz); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx + half, cy + off, cz); iFrame.setMatrixAt(iIF++, M);

      M.identity().makeRotationZ(Math.PI/2).setPosition(cx + off, cy - half, cz); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationZ(Math.PI/2).setPosition(cx + off, cy + half, cz); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx + off, cy, cz - half); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx + off, cy, cz + half); iFrame.setMatrixAt(iIF++, M);
    }
  }

  [frameX,frameY,frameZ,lineX,lineY,lineZ,iFrame].forEach(im=>{im.instanceMatrix.needsUpdate=true; group.add(im);});

  const glows = new THREE.InstancedMesh(geoGlow, matGlow.clone(),  qualityParams().glowCount);
  const M2 = new THREE.Matrix4();
  for(let i=0;i<qualityParams().glowCount;i++){
    const ax=(Math.random()*3)|0;
    const ring=(Math.random()*(GRID_COUNT*2+1)|0)-GRID_COUNT;
    const base=ring*qualityParams().cell, h=qualityParams().cell/2;
    let x=0,y=1.6,z=0,rx=0,ry=0,rz=0;
    if(ax===0){ x=0; y=1.6+(Math.random()*2-1)*h; z=(Math.random()<.5?-1:1)*h + base; ry=Math.PI/2; }
    if(ax===1){ x=(Math.random()<.5?-1:1)*h + base; y=1.6; z=(Math.random()*2-1)*h; rx=Math.PI/2; }
    if(ax===2){ x=(Math.random()*2-1)*h + base; y=1.6+(Math.random()<.5?-1:1)*h; z=0; }
    M2.identity().makeRotationFromEuler(new THREE.Euler(rx,ry,rz)).setPosition(x,y,z);
    glows.setMatrixAt(i, M2);
  }
  glows.instanceMatrix.needsUpdate=true;
  group.add(glows);

  group.userData.tick = (t)=>{
    const a = 0.18;
    const s = 1.00 + 0.03*Math.sin(t*0.6 + phase);
    group.position.z = Math.sin(t*0.5 + phase) * a;
    group.scale.set(1.00, s, 1.00/s);
  };
  return group;
}

/* -------- –ø–æ–ª–µ ¬´–±–æ–∫–µ¬ª -------- */
function buildBokehField(p){
  const n = isQuest ? 140 : 220;
  const geo = new THREE.PlaneGeometry(1,1);
  const mat = new THREE.MeshBasicMaterial({map:bokehTex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:0.32});
  const inst = new THREE.InstancedMesh(geo, mat, n);
  const M = new THREE.Matrix4();

  for(let i=0;i<n;i++){
    const r = GRID_COUNT*p.cell + 3.0;
    const x=(Math.random()*2-1)*r, y=1.6+(Math.random()*2-1)*r*0.6, z=(Math.random()*2-1)*r;
    const s = 0.6 + Math.random()*3.0;
    M.identity().setPosition(x,y,z);
    M.multiply(new THREE.Matrix4().makeScale(s, s, s));
    inst.setMatrixAt(i, M);
  }
  inst.instanceMatrix.needsUpdate=true;
  inst.userData.tick=(t)=>{ inst.material.opacity = 0.22 + 0.18*(0.5+0.5*Math.sin(t*0.7)); };
  return inst;
}

/* -------- –í–û–°–ü–û–ú–ò–ù–ê–ù–ò–Ø ‚Äî –æ—Ç–¥–µ–ª—å–Ω—ã–π —è–∫–æ—Ä—å -------- */
function buildMemories(p){
  const group = new THREE.Group();
  const loader = new THREE.TextureLoader();
  const textures = [];
  PHOTO_FILES.forEach(path=>{
    const tex = loader.load(path);
    if ('colorSpace' in tex) tex.colorSpace = THREE.SRGBColorSpace; else tex.encoding = THREE.sRGBEncoding;
    textures.push(tex);
  });

  const sceneRadius = GRID_COUNT * p.cell + 3.0;
  const rMin = sceneRadius * PHOTO_RANGE[0];
  const rMax = sceneRadius * PHOTO_RANGE[1];

  const rnd = (a,b)=>a + Math.random()*(b-a);
  const pick = arr => arr[(Math.random()*arr.length)|0];

  function placeRandom(m){
    const axis = (Math.random()*3)|0;
    const ring = ((Math.random()*(GRID_COUNT*2+1))|0) - GRID_COUNT;
    const base = ring * p.cell;
    const half = p.cell/2;

    let x=0,y=1.6,z=0;
    if(axis===0){ x=0; y=1.6 + rnd(-half, half); z=(Math.random()<.5?-1:1)*half + base + rnd(-0.35,0.35); }
    else if(axis===1){ x=(Math.random()<.5?-1:1)*half + base + rnd(-0.35,0.35); y=1.6; z=rnd(-half, half); }
    else { x=rnd(-half, half); y=1.6 + (Math.random()<.5?-1:1)*half + rnd(-0.35,0.35); z=0; }

    const scaleR = rMin + Math.random()*(rMax - rMin);
    const len = Math.hypot(x, y-1.6, z) || 1;
    x *= scaleR/len; y = 1.6 + (y-1.6)*scaleR/len; z *= scaleR/len;

    const d = Math.hypot(x, y-1.6, z);
    if (d < PHOTO_NEAR){
      const k = PHOTO_NEAR/d;
      x*=k; z*=k; y = 1.6 + (y-1.6)*k;
    }
    m.position.set(x,y,z);
    m.lookAt(0,1.6,0);
    m.material.opacity = 0.0;
  }

  for(let i=0;i<PHOTO_POOL;i++){
    const tex = pick(textures);
    const ar = (tex.image?.width||1) / (tex.image?.height||1);
    const w  = PHOTO_SIZE * (0.9 + Math.random()*0.4);
    const h  = w / ar;

    const mat = new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:0.0, depthWrite:false, side:THREE.DoubleSide});
    const geo = new THREE.PlaneGeometry(w, h);
    const m = new THREE.Mesh(geo, mat);

    m.userData.state = 'cooldown';
    m.userData.t = rnd(...PHOTO_COOLDOWN);
    m.userData.fade = rnd(0.45,0.7);
    m.userData.hold = rnd(...PHOTO_LIFETIME);

    group.add(m);
  }

  group.userData.tick = (dt, t)=>{
    group.children.forEach((m)=>{
      if(m.userData.state==='cooldown'){
        m.userData.t -= dt;
        if(m.userData.t<=0){
          placeRandom(m);
          if(Math.random()<0.6){
            const tex = pick(textures);
            if ('colorSpace' in tex) tex.colorSpace = THREE.SRGBColorSpace; else tex.encoding = THREE.sRGBEncoding;
            m.material.map = tex; m.material.needsUpdate = true;
          }
          m.userData.state='fadein';
          m.userData.t = m.userData.fade;
        }
      }else if(m.userData.state==='fadein'){
        const k = 1 - Math.max(0, m.userData.t)/Math.max(0.0001, m.userData.fade);
        m.material.opacity = Math.min(PHOTO_OPACITY_MAX, k*PHOTO_OPACITY_MAX);
        m.userData.t -= dt;
        if(m.userData.t<=0){ m.userData.state='hold'; m.userData.t=m.userData.hold; }
      }else if(m.userData.state==='hold'){
        const pulse = 0.04*Math.sin(t*0.8 + ((m.id*9301 + 49297) % 233280));
        m.material.opacity = Math.max(0, Math.min(PHOTO_OPACITY_MAX, PHOTO_OPACITY_MAX - 0.05 + pulse));
        m.userData.t -= dt;
        if(m.userData.t<=0){ m.userData.state='fadeout'; m.userData.t=m.userData.fade; }
      }else if(m.userData.state==='fadeout'){
        const k = Math.max(0, m.userData.t)/Math.max(0.0001, m.userData.fade);
        m.material.opacity = Math.max(0, k*PHOTO_OPACITY_MAX);
        m.userData.t -= dt;
        if(m.userData.t<=0){ m.userData.state='cooldown'; m.userData.t = rnd(...PHOTO_COOLDOWN); m.material.opacity=0; }
      }
    });
  };

  return group;
}

/* -------- —Å–±–æ—Ä–∫–∞ —Å—Ü–µ–Ω—ã -------- */
let root=null, memoriesAnchor=null, memories=null;
function rebuild(){
  if(root){ scene.remove(root); root.traverse(o=>{ if(o.dispose) o.dispose(); }); root=null; }
  if(memoriesAnchor){ scene.remove(memoriesAnchor); memoriesAnchor=null; memories=null; }

  const P = qualityParams();

  root = new THREE.Group();
  const layers = Math.max(2, P.layers||2);
  for(let i=0;i<layers;i++){
    const tint = 0.9 + i*0.08;
    const phase = i*1.2;
    root.add( buildTesseractLayer(P, phase, tint) );
  }
  root.add( buildBokehField(P) );
  scene.add(root);

  memoriesAnchor = new THREE.Group();
  memories = buildMemories(P);
  memoriesAnchor.add(memories);
  scene.add(memoriesAnchor);
}

/* -------- –º—É–∑—ã–∫–∞ -------- */
const MUSIC_PATH = './assets/music/universe.mp3';
let audioCtx=null, musicNode=null, musicGain=null, musicStarted=false, musicMuted=false;
async function ensureMusic(){
  try{
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    if(musicStarted) return;
    const resp=await fetch(MUSIC_PATH); const buf=await resp.arrayBuffer();
    const audioBuf=await audioCtx.decodeAudioData(buf);
    musicGain=audioCtx.createGain(); musicGain.gain.value=0.0001;
    musicNode=audioCtx.createBufferSource(); musicNode.buffer=audioBuf; musicNode.loop=true;
    musicNode.connect(musicGain).connect(audioCtx.destination); musicNode.start();
    const t=audioCtx.currentTime; musicGain.gain.exponentialRampToValueAtTime(0.10, t+2.0);
    musicStarted=true; updateMuteUI();
  }catch(e){ console.warn('–ú—É–∑—ã–∫–∞ –Ω–µ —Å—Ç–∞—Ä—Ç–∞–Ω—É–ª–∞:',e); }
}
function setMuted(m){ musicMuted=m; if(musicGain){ const t=audioCtx.currentTime; musicGain.gain.cancelScheduledValues(t); musicGain.gain.exponentialRampToValueAtTime(m?0.0001:0.10, t+0.25);} updateMuteUI();}
function toggleMute(){ setMuted(!musicMuted); }
function updateMuteUI(){ document.getElementById('mute').textContent = musicMuted ? 'üîá –ë–µ–∑ –∑–≤—É–∫–∞' : 'üîä –ú—É–∑—ã–∫–∞'; }

/* -------- –º–µ–Ω—é/–∑–∞–≥—Ä—É–∑–∫–∞ -------- */
const loading=document.getElementById('loading');
const menu=document.getElementById('menu');
requestAnimationFrame(()=>{ rebuild(); loading.style.display='none'; menu.style.display='flex'; });

/* ================= XR —Å—Ç–∞—Ä—Ç –±–µ–∑ —á—ë—Ä–Ω–æ–≥–æ: DOM-–æ–≤–µ—Ä–ª–µ–π + XR-–∫–∞–¥—Ä—ã ================= */
let xrSession = null;
let hideTimeout = null;

function showBlack(){ const b=document.getElementById('black'); b.style.display='block'; b.style.opacity='1'; }
function hideBlack(){ const b=document.getElementById('black'); b.style.opacity='0'; setTimeout(()=>{ b.style.display='none'; }, 750); }

function waitXRFrames(session, n, done){
  let i=0;
  function onFrame(){ i++; if(i>=n){ done(); } else { session.requestAnimationFrame(onFrame); } }
  session.requestAnimationFrame(onFrame);
}

async function startXR(){
  if(!navigator.xr){ alert('WebXR –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –û—Ç–∫—Ä–æ–π –≤ Quest Browser.'); return; }

  renderer.render(scene, camera); // –ø—Ä–æ–≥—Ä–µ–≤
  showBlack();

  const session = await navigator.xr.requestSession('immersive-vr', {
    requiredFeatures: ['local-floor'],
    optionalFeatures: ['bounded-floor']
  });

  await renderer.xr.setSession(session);
  xrSession = session;

  if (renderer.xr.setFoveation) { try{ renderer.xr.setFoveation(0.5); }catch(_){} }

  const onVis = ()=>{
    if (session.visibilityState === 'visible'){
      if (hideTimeout){ clearTimeout(hideTimeout); hideTimeout=null; }
      waitXRFrames(session, 2, hideBlack);
    } else {
      showBlack();
    }
  };
  session.addEventListener('visibilitychange', onVis);
  onVis();
  hideTimeout = setTimeout(hideBlack, 2000);

  session.addEventListener('end', ()=>{
    xrSession = null;
    showBlack();
    const menu = document.getElementById('menu');
    if (menu) menu.style.display='flex';
  });
}

/* -------- –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª -------- */
let lastTS = performance.now()*0.001;
renderer.setAnimationLoop(()=>{
  const now=performance.now()*0.001, dt=Math.min(0.05, now-lastTS); lastTS=now;
  if(root) root.traverse(o=>{ if(o.userData && o.userData.tick) o.userData.tick(now,dt); });
  if(memories && memories.userData && memories.userData.tick) memories.userData.tick(dt, now);
  if(controls.enabled) controls.update();
  renderer.render(scene,camera);
});

/* -------- –∫–Ω–æ–ø–∫–∏ -------- */
document.getElementById('btnVR').addEventListener('click', async ()=>{
  menu.style.display='none';
  ensureMusic();
  await startXR();
});
document.getElementById('btnSpectate').addEventListener('click', ()=>{
  menu.style.display='none';
  controls.enabled=true;
  ensureMusic();
  showBlack(); setTimeout(hideBlack,150);
});
document.getElementById('mute').addEventListener('click', ()=>{ ensureMusic(); toggleMute(); });

/* -------- input/resize -------- */
addEventListener('click', ()=>{ ensureMusic(); });
addEventListener('touchstart', ()=>{ ensureMusic(); }, {passive:true});
addEventListener('keydown', e=>{ if(e.code==='KeyM'){ ensureMusic(); toggleMute(); } });
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
</script>
</body>
</html>
