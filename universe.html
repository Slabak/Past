<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>–¢–µ—Å—Å–µ—Ä–∞–∫—Ç ‚Äî –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∫–æ–º–Ω–∞—Ç—ã</title>
<script src="./assets/js/three.min.js"></script>
<script src="./assets/js/OrbitControls.js"></script>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:30}
  .menu{position:fixed;inset:0;background:rgba(0,0,0,.88);display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;z-index:20}
  .btn{appearance:none;border:0;padding:12px 16px;border-radius:12px;font-weight:600;cursor:pointer;font-size:15px;background:#14b8a6;color:#00100e;box-shadow:0 4px 20px rgba(0,0,0,.35)}
  .btn.secondary{background:#1f2937;color:#cbd5e1}
  .hud{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:13px;z-index:5}
  .mute{position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2);padding:8px 10px;border-radius:10px;font-size:13px;z-index:6;cursor:pointer}
</style>
</head>
<body>
  <div id="loading" class="overlay"><div>–°–æ–±–∏—Ä–∞—é —Ç–µ—Å—Å–µ—Ä–∞–∫—Ç‚Ä¶</div></div>
  <div id="menu" class="menu">
    <button id="btnVR" class="btn">–í–æ–π—Ç–∏ –≤ VR</button>
    <button id="btnSpectate" class="btn secondary">–†–µ–∂–∏–º –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è</button>
  </div>
  <div class="hud">–ü–ö: –º—ã—à—å ‚Äî –æ–±–∑–æ—Ä. –ö–ª–∏–∫ –ø—Ä–æ—Å—Ç–æ –≤–∫–ª—é—á–∞–µ—Ç –º—É–∑—ã–∫—É. –ö–∞–º–µ—Ä–∞ –æ—Å—Ç–∞—ë—Ç—Å—è –≥–¥–µ —Å—Ç–æ—è–ª–∞.</div>
  <button id="mute" class="mute">üîä –ú—É–∑—ã–∫–∞</button>

<script>
/*** –ù–ê–°–¢–†–û–ô–ö–ò ***/
const MUSIC_PATH = './assets/music/universe.mp3';
const isMobile = /Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);

// —Å–µ—Ç–∫–∞ ¬´–∫–æ–º–Ω–∞—Ç¬ª
const GRID = {
  cell: 3.0,          // —Ä–∞–∑–º–µ—Ä —è—á–µ–π–∫–∏ (—Ä–µ–±—Ä–æ –∫—É–±–∞), –º
  count: 3,           // —Ä–∞–¥–∏—É—Å –≤ —è—á–µ–π–∫–∞—Ö (3 => 7√ó7√ó7)
  beam: 0.09,         // —Ç–æ–ª—â–∏–Ω–∞ —Ä–µ–µ–∫ –∫–∞—Ä–∫–∞—Å–∞
  slat: 0.035,        // —Ç–æ–ª—â–∏–Ω–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö ¬´–ª–∏–Ω–∏–π¬ª
  emptyRadius: 1.45,  // —Ä–∞–¥–∏—É—Å –ø—É—Å—Ç–æ–≥–æ —è–¥—Ä–∞ (–≤–æ–∫—Ä—É–≥ –∫–∞–º–µ—Ä—ã)
  glassRatio: 0.35,   // –¥–æ–ª—è —Å—Ç–µ–∫–ª—è–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  fillDensity: isMobile ? 3 : 5 // —Å–∫–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Ä–µ–µ–∫ –Ω–∞ –≥—Ä–∞–Ω—å (–ø–æ –∫–∞–∂–¥–æ–π –æ—Å–∏)
};

/*** –°–¶–ï–ù–ê ***/
const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.55;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, 0.028);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 1200);
camera.position.set(0,1.6,0.01);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enabled = false; controls.target.set(0,1.6,0);

/*** –®–¢–û–†–ö–ê –î–õ–Ø VR ***/
function makeFade(){const g=new THREE.PlaneGeometry(2,2),m=new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:1,depthTest:false});const q=new THREE.Mesh(g,m);q.renderOrder=9999;q.position.z=-0.3;camera.add(q);scene.add(camera);return{show:()=>m.opacity=1,fade:(ms=700)=>{const t0=performance.now();(function f(t){const k=Math.min(1,(t-t0)/ms);m.opacity=1-k;if(k<1)requestAnimationFrame(f)})(t0)}}}
const screen = makeFade(); let xrFadePending=false, xrFrames=0;

/*** –°–í–ï–¢ ***/
const key = new THREE.DirectionalLight(0xffe0b5, 0.65); key.position.set(-2.5,5,-4.5); scene.add(key);
const rim = new THREE.DirectionalLight(0xbfd4ff, 0.22);  rim.position.set( 3.0,2.0, 3.5); scene.add(rim);
scene.add(new THREE.AmbientLight(0x0c0906, 0.68));

/*** –ú–ê–¢–ï–†–ò–ê–õ–´ ***/
function woodTex(){
  const c=document.createElement('canvas'); c.width=1024; c.height=64; const ctx=c.getContext('2d');
  for(let x=0;x<c.width;x++){ const hue=35+Math.random()*10, sat=25+Math.random()*20, l=14+Math.random()*10;
    ctx.fillStyle=`hsl(${hue} ${sat}% ${l}%)`; ctx.fillRect(x,0,1,c.height);
  }
  const t=new THREE.CanvasTexture(c);
  t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(8,1);
  if ('colorSpace' in t) t.colorSpace = THREE.SRGBColorSpace; else t.encoding = THREE.sRGBEncoding;
  return t;
}
const matWood  = new THREE.MeshStandardMaterial({map:woodTex(), roughness:0.95, metalness:0.05, color:0xffffff});
const matGlass = new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.05, roughness:0.08, transparent:true, opacity:0.38, envMapIntensity:0.7});
const matGlow  = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.7, blending:THREE.AdditiveBlending, depthWrite:false});

/*** –ì–ï–ù–ï–†–ê–¢–û–†: –°–ï–¢–ö–ê –ö–û–ú–ù–ê–¢ + –í–ù–£–¢–†–ï–ù–ù–ò–ï ¬´–õ–ò–ù–ò–ò¬ª ***/
function buildFilledRoomsGrid(cfg){
  const g = new THREE.Group();
  const {cell,count,beam,slat,emptyRadius,glassRatio,fillDensity} = cfg;

  // —Ä–µ–µ—á–∫–∏ –∫–∞—Ä–∫–∞—Å–∞
  const geoX = new THREE.BoxGeometry(cell, beam, beam);
  const geoY = new THREE.BoxGeometry(beam, cell, beam);
  const geoZ = new THREE.BoxGeometry(beam, beam, cell);

  // –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ ¬´–ª–∏–Ω–∏–∏¬ª (—Ç–æ–Ω–∫–∏–µ —Ä–µ–π–∫–∏/–ø–∞–Ω–µ–ª–∏)
  const geoLineX = new THREE.BoxGeometry(cell, slat, slat);
  const geoLineY = new THREE.BoxGeometry(slat, cell, slat);
  const geoLineZ = new THREE.BoxGeometry(slat, slat, cell);

  function add(m,x,y,z){ m.position.set(x,y,z); g.add(m); }

  const half = cell/2;
  const steps = fillDensity;                 // —Å–∫–æ–ª—å–∫–æ ¬´–ª–∏–Ω–∏–∏–π¬ª –Ω–∞ –≥—Ä–∞–Ω—å (–ø–æ –æ—Å–∏)
  const step  = cell/(steps+1);              // —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –Ω–∏–º–∏

  for(let ix=-count; ix<=count; ix++){
    for(let iy=-count; iy<=count; iy++){
      for(let iz=-count; iz<=count; iz++){
        const cx = ix*cell, cy = 1.6 + iy*cell, cz = iz*cell;

        // –Ω–µ —Å—Ç—Ä–æ–∏–º —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ —Ü–µ–Ω—Ç—Ä—É
        const near = Math.hypot(cx,cy-1.6,cz) < emptyRadius + cell*0.5;
        if(near) continue;

        const baseMat = (Math.random()<glassRatio? matGlass : matWood);

        // 12 —Ä—ë–±–µ—Ä –∫–∞—Ä–∫–∞—Å–∞
        add(new THREE.Mesh(geoX, baseMat.clone()), cx, cy - half, cz - half);
        add(new THREE.Mesh(geoX, baseMat.clone()), cx, cy - half, cz + half);
        add(new THREE.Mesh(geoX, baseMat.clone()), cx, cy + half, cz - half);
        add(new THREE.Mesh(geoX, baseMat.clone()), cx, cy + half, cz + half);

        add(new THREE.Mesh(geoY, baseMat.clone()), cx - half, cy, cz - half);
        add(new THREE.Mesh(geoY, baseMat.clone()), cx + half, cy, cz - half);
        add(new THREE.Mesh(geoY, baseMat.clone()), cx - half, cy, cz + half);
        add(new THREE.Mesh(geoY, baseMat.clone()), cx + half, cy, cz + half);

        add(new THREE.Mesh(geoZ, baseMat.clone()), cx - half, cy - half, cz);
        add(new THREE.Mesh(geoZ, baseMat.clone()), cx + half, cy - half, cz);
        add(new THREE.Mesh(geoZ, baseMat.clone()), cx - half, cy + half, cz);
        add(new THREE.Mesh(geoZ, baseMat.clone()), cx + half, cy + half, cz);

        // –í–ù–£–¢–†–ï–ù–ù–ï–ï –ó–ê–ü–û–õ–ù–ï–ù–ò–ï ‚Äî —Ç–æ–Ω–∫–∏–µ —Ä–µ–π–∫–∏ –ø–æ —Ç—Ä—ë–º –æ—Å—è–º (—Å –∑–∞–∑–æ—Ä–æ–º –æ—Ç —Ü–µ–Ω—Ç—Ä–∞)
        for(let i=1;i<=steps;i++){
          const d = -half + i*step;

          // –ø–∞—Ä–∞–ª–ª–µ–ª–∏ –ø–ª–æ—Å–∫–æ—Å—Ç—è–º XY (–ª–∏–Ω–∏–∏ –≤–¥–æ–ª—å X, —Ä–∞—Å–∫–ª–∞–¥ –ø–æ Z)
          if (Math.abs(d) > slat*1.5) {
            add(new THREE.Mesh(geoLineX, baseMat.clone()), cx, cy, cz + d);
            add(new THREE.Mesh(geoLineX, baseMat.clone()), cx, cy, cz - d);
          }

          // –ø–∞—Ä–∞–ª–ª–µ–ª–∏ XZ (–ª–∏–Ω–∏–∏ –≤–¥–æ–ª—å Z, —Ä–∞—Å–∫–ª–∞–¥ –ø–æ Y)
          if (Math.abs(d) > slat*1.5) {
            add(new THREE.Mesh(geoLineZ, baseMat.clone()), cx, cy + d, cz);
            add(new THREE.Mesh(geoLineZ, baseMat.clone()), cx, cy - d, cz);
          }

          // –ø–∞—Ä–∞–ª–ª–µ–ª–∏ YZ (–ª–∏–Ω–∏–∏ –≤–¥–æ–ª—å Y, —Ä–∞—Å–∫–ª–∞–¥ –ø–æ X)
          if (Math.abs(d) > slat*1.5) {
            add(new THREE.Mesh(geoLineY, baseMat.clone()), cx + d, cy, cz);
            add(new THREE.Mesh(geoLineY, baseMat.clone()), cx - d, cy, cz);
          }
        }

        // –ø–∞—Ä—É ¬´—Å–≤–µ—Ç—è—â–∏—Ö—Å—è —â–µ–ª–µ–π¬ª –≤ —Å–ª—É—á–∞–π–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö –∫—É–±–∞
        for(let s=0;s<2;s++){
          const glow = new THREE.Mesh(
            Math.random()<0.5 ? new THREE.PlaneGeometry(0.3, 1.1) : new THREE.PlaneGeometry(1.1, 0.3),
            matGlow.clone()
          );
          glow.material.opacity = 0.35 + Math.random()*0.45;
          const axis = (Math.random()*3)|0;
          if(axis===0){ glow.position.set(cx, cy + (Math.random()*2-1)*half, cz + (Math.random()<.5?-1:1)*half); glow.rotation.y=Math.PI/2; }
          if(axis===1){ glow.position.set(cx + (Math.random()<.5?-1:1)*half, cy, cz + (Math.random()*2-1)*half); glow.rotation.x=Math.PI/2; }
          if(axis===2){ glow.position.set(cx + (Math.random()*2-1)*half, cy + (Math.random()<.5?-1:1)*half, cz); }
          glow.userData.p = Math.random()*Math.PI*2;
          g.add(glow);
        }
      }
    }
  }

  // –¥—ã—Ö–∞–Ω–∏–µ
  g.userData.update = (dt,t)=>{
    g.rotation.y = Math.sin(t*0.03)*0.05;
    g.position.x = Math.sin(t*0.05+1.2)*0.18;
    g.position.z = Math.sin(t*0.06)*0.22;
    // –ø—É–ª—å—Å —â–µ–ª–µ–π
    g.children.forEach(ch=>{
      if(ch.material && ch.material.blending===THREE.AdditiveBlending && ch.userData.p!==undefined){
        ch.material.opacity = 0.22 + 0.55*(0.5+0.5*Math.sin(t*0.7 + ch.userData.p));
        ch.lookAt(camera.position);
      }
    });
  };
  return g;
}

const grid = buildFilledRoomsGrid(GRID);
scene.add(grid);

/*** –ú–£–ó–´–ö–ê (–±–µ–∑ —Ç—Ä—è—Å–∫–∏ –∏ ¬´—Å—Ç—É–∫–∞¬ª) ***/
let audioCtx=null, musicNode=null, musicGain=null, musicStarted=false, musicMuted=false;
async function ensureMusic(){
  try{
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    if(musicStarted) return;
    const resp=await fetch(MUSIC_PATH); const buf=await resp.arrayBuffer();
    const audioBuf=await audioCtx.decodeAudioData(buf);
    musicGain=audioCtx.createGain(); musicGain.gain.value=0.0001;
    musicNode=audioCtx.createBufferSource(); musicNode.buffer=audioBuf; musicNode.loop=true;
    musicNode.connect(musicGain).connect(audioCtx.destination); musicNode.start();
    const t=audioCtx.currentTime; musicGain.gain.exponentialRampToValueAtTime(0.10, t+2.0);
    musicStarted=true; updateMuteUI();
  }catch(e){ console.warn('–ú—É–∑—ã–∫–∞ –Ω–µ —Å—Ç–∞—Ä—Ç–∞–Ω—É–ª–∞:',e); }
}
function setMuted(m){ musicMuted=m; if(musicGain){ const t=audioCtx.currentTime; musicGain.gain.cancelScheduledValues(t); musicGain.gain.exponentialRampToValueAtTime(m?0.0001:0.10, t+0.25);} updateMuteUI();}
function toggleMute(){ setMuted(!musicMuted); }
function updateMuteUI(){ document.getElementById('mute').textContent = musicMuted ? 'üîá –ë–µ–∑ –∑–≤—É–∫–∞' : 'üîä –ú—É–∑—ã–∫–∞'; }

/*** –ú–ï–ù–Æ / VR ***/
const loading=document.getElementById('loading');
const menu=document.getElementById('menu');
requestAnimationFrame(()=>{ loading.style.display='none'; menu.style.display='flex'; });

renderer.xr.addEventListener('sessionstart', ()=>{
  controls.enabled=false; screen.show(); xrFadePending=true; xrFrames=0; ensureMusic();
});
document.getElementById('btnVR').onclick = async ()=>{ menu.style.display='none'; screen.show(); await startXR(); };
document.getElementById('btnSpectate').onclick = ()=>{ menu.style.display='none'; controls.enabled=true; screen.show(); ensureMusic(); setTimeout(()=>screen.fade(700),150); };
document.getElementById('mute').onclick = ()=>{ ensureMusic().then(()=>toggleMute()); };

/*** –¶–ò–ö–õ ***/
let last=performance.now()*0.001;
renderer.setAnimationLoop(()=>{
  const now=performance.now()*0.001, dt=Math.min(0.033, now-last); last=now;
  if (renderer.xr.isPresenting && xrFadePending){ xrFrames++; if(xrFrames>=4){ screen.fade(700); xrFadePending=false; } }
  if(grid.userData.update) grid.userData.update(dt, now);
  if(controls.enabled) controls.update();
  renderer.render(scene,camera);
});

/*** XR ***/
async function startXR(){
  if(!navigator.xr){ alert('WebXR –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –û—Ç–∫—Ä–æ–π –≤ Quest Browser.'); return; }
  try{ const s=await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor','bounded-floor']}); await renderer.xr.setSession(s); }
  catch(e){ console.error(e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å VR-—Å–µ—Å—Å–∏—é.'); }
}

/*** INPUT / RESIZE ***/
// –ö–ª–∏–∫ ‚Äî —Ç–æ–ª—å–∫–æ –º—É–∑—ã–∫–∞, –ë–ï–ó —Ç—Ä—è—Å–∫–∏/—Å–±—Ä–æ—Å–æ–≤
addEventListener('click', ()=>{ ensureMusic(); });
addEventListener('touchstart', ()=>{ ensureMusic(); }, {passive:true});
addEventListener('keydown', e=>{ if(e.code==='KeyM'){ ensureMusic().then(()=>toggleMute()); } });
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
</script>
</body>
</html>
