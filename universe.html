<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>–¢–µ—Å—Å–µ—Ä–∞–∫—Ç ‚Äî —Å—Ç–∞–±–∏–ª—å–Ω–∞—è ¬´–∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è¬ª –≤–µ—Ä—Å–∏—è</title>
<script src="./assets/js/three.min.js"></script>
<script src="./assets/js/OrbitControls.js"></script>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:30}
  .menu{position:fixed;inset:0;background:rgba(0,0,0,.88);display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;z-index:20}
  .btn{appearance:none;border:0;padding:12px 16px;border-radius:12px;font-weight:600;cursor:pointer;font-size:15px;background:#14b8a6;color:#00100e;box-shadow:0 4px 20px rgba(0,0,0,.35)}
  .btn.secondary{background:#1f2937;color:#cbd5e1}
  .hud{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:13px;z-index:5}
  .mute{position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2);padding:8px 10px;border-radius:10px;font-size:13px;z-index:6;cursor:pointer}
  .quality{position:fixed;right:12px;top:12px;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2);padding:6px 8px;border-radius:10px;font-size:13px;z-index:7}
</style>
</head>
<body>
  <div id="loading" class="overlay"><div>–°–æ–±–∏—Ä–∞—é —Ç–µ—Å—Å–µ—Ä–∞–∫—Ç‚Ä¶</div></div>
  <div id="menu" class="menu">
    <button id="btnVR" class="btn">–í–æ–π—Ç–∏ –≤ VR</button>
    <button id="btnSpectate" class="btn secondary">–†–µ–∂–∏–º –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è</button>
  </div>
  <div class="hud">–ü–ö: –º—ã—à—å ‚Äî –æ–±–∑–æ—Ä. –ö–ª–∏–∫ –≤–∫–ª—é—á–∞–µ—Ç –º—É–∑—ã–∫—É. –ö–∞–º–µ—Ä–∞ –Ω–µ —Ç—Ä—è—Å—ë—Ç—Å—è.</div>
  <button id="mute" class="mute">üîä –ú—É–∑—ã–∫–∞</button>
  <div class="quality">
    –ö–∞—á–µ—Å—Ç–≤–æ:
    <select id="qsel">
      <option value="auto" selected>auto</option>
      <option value="low">low</option>
      <option value="med">med</option>
      <option value="high">high</option>
    </select>
  </div>

<script>
const ua = navigator.userAgent;
const isQuest  = /Quest|Oculus/i.test(ua);
const isMobile = /Android|iPhone|iPad|iPod|Quest|Oculus/i.test(ua);

const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2; // —Ç–µ–º–Ω–µ–µ, —á—Ç–æ–±—ã –Ω–µ ¬´—Å–≤–µ—Ç–∏–ª–æ¬ª
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 2000);
camera.position.set(0,1.6,0.01);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enabled = false; controls.target.set(0,1.6,0);

/* –º—è–≥–∫–∏–π —Ñ–µ–π–¥ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ VR */
function makeFade(){const g=new THREE.PlaneGeometry(2,2),m=new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:1,depthTest:false});const q=new THREE.Mesh(g,m);q.renderOrder=9999;q.position.z=-0.3;camera.add(q);scene.add(camera);return{show:()=>m.opacity=1,fade:(ms=700)=>{const t0=performance.now();(function f(t){const k=Math.min(1,(t-t0)/ms);m.opacity=1-k;if(k<1)requestAnimationFrame(f)})(t0)}}}
const screen = makeFade(); let xrFadePending=false, xrFrames=0;

/* —Å–≤–µ—Ç –Ω–µ–∂–Ω—ã–π */
scene.add(new THREE.AmbientLight(0x120e0b, 0.9));
const key = new THREE.DirectionalLight(0xffe0b5, 0.4); key.position.set(-2.5,5,-4.5); scene.add(key);
const rim = new THREE.DirectionalLight(0xbfd4ff, 0.14);  rim.position.set( 3.0,2.0, 3.5); scene.add(rim);

/* –ø—Ä–æ—Ñ–∏–ª–∏ –∫–∞—á–µ—Å—Ç–≤–∞ */
function pickQuality(){
  const v = document.getElementById('qsel').value;
  if (v!=='auto') return v;
  if (isQuest) return 'low';
  return isMobile ? 'med' : 'high';
}
function qualityParams(q){
  if(q==='low')  return {cell:3, count:2, distance:3.6, frame:0.085, slat:0.024, fillProb:0.12, planesPerAxis:1, layers:2};
  if(q==='med')  return {cell:3, count:3, distance:3.8, frame:0.090, slat:0.024, fillProb:0.18, planesPerAxis:2, layers:2};
  /* high */     return {cell:3, count:3, distance:4.0, frame:0.095, slat:0.022, fillProb:0.25, planesPerAxis:2, layers:3};
}

/* —Ç–µ–∫—Å—Ç—É—Ä–∞ –º—è–≥–∫–æ–π –ø–æ–ª–æ—Å—ã */
function lineTexture(){
  const w=512,h=64,c=document.createElement('canvas');c.width=w;c.height=h;
  const ctx=c.getContext('2d');
  const g=ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'rgba(255,255,255,0)'); g.addColorStop(0.35,'rgba(255,255,255,0.20)');
  g.addColorStop(0.50,'rgba(255,255,255,0.75)'); g.addColorStop(0.65,'rgba(255,255,255,0.20)');
  g.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  const t=new THREE.CanvasTexture(c); t.generateMipmaps=false;
  t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter;
  if('colorSpace' in t) t.colorSpace=THREE.SRGBColorSpace; else t.encoding=THREE.sRGBEncoding;
  return t;
}
const STRIP_TEX = lineTexture();

function stripMaterial(op){ return new THREE.MeshBasicMaterial({
  map: STRIP_TEX, color:0xE6D5B9, transparent:true, opacity:op, depthWrite:false, side:THREE.DoubleSide
});}

/* —Å–±–æ—Ä–∫–∞ —Å–ª–æ—è */
function buildLayer(P, phase=0, tint=1.0){
  const {cell,count,distance,frame,slat,fillProb,planesPerAxis} = P;
  const group = new THREE.Group();
  const half = cell/2;

  // –∫–∞—Ä–∫–∞—Å
  const matHard = new THREE.MeshLambertMaterial({color:0x3a2d22});
  const matSoft = new THREE.MeshBasicMaterial({color:0x6f5640, transparent:true, opacity:0.12});
  const geoX = new THREE.BoxGeometry(cell, frame, frame);
  const geoY = new THREE.BoxGeometry(frame, cell, frame);
  const geoZ = new THREE.BoxGeometry(frame, frame, cell);
  const geoLX= new THREE.BoxGeometry(cell, slat, slat);
  const geoLY= new THREE.BoxGeometry(slat, cell, slat);
  const geoLZ= new THREE.BoxGeometry(slat, slat, cell);

  const frameX=new THREE.InstancedMesh(geoX, matHard, 1);
  const frameY=new THREE.InstancedMesh(geoY, matHard, 1);
  const frameZ=new THREE.InstancedMesh(geoZ, matHard, 1);
  const lineX =new THREE.InstancedMesh(geoLX,matSoft, 1);
  const lineY =new THREE.InstancedMesh(geoLY,matSoft, 1);
  const lineZ =new THREE.InstancedMesh(geoLZ,matSoft, 1);

  // ¬´–Ω–∞—á–∏–Ω–∫–∞¬ª ‚Äî —É–º–µ—Ä–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ –ø–æ–ª–æ—Å (–ø–ª–æ—Å–∫–æ—Å—Ç–µ–π) –ø–æ –∫–∞–∂–¥–æ–π –æ—Å–∏
  const stripH=0.055;
  const planeX=new THREE.PlaneGeometry(cell, stripH*1.7);
  const planeY=new THREE.PlaneGeometry(cell, stripH*1.7);
  const planeZ=new THREE.PlaneGeometry(cell, stripH*1.7);
  const matCore=stripMaterial(0.45*tint), matHalo=stripMaterial(0.20*tint);

  // –ñ—ë—Å—Ç–∫–∏–π –ª–∏–º–∏—Ç –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤ (—á—Ç–æ–±—ã –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ ¬´–∑–∞—Å–Ω–µ–∂–∏–≤–∞–ª–æ¬ª)
  const maxCells = Math.pow(count*2+1,3);
  const MAX_STRIPS = maxCells * (planesPerAxis*3 + 8); // –∑–∞–ø–∞—Å
  const sX=new THREE.InstancedMesh(planeX,matCore,MAX_STRIPS);
  const sY=new THREE.InstancedMesh(planeY,matCore,MAX_STRIPS);
  const sZ=new THREE.InstancedMesh(planeZ,matCore,MAX_STRIPS);
  const hX=new THREE.InstancedMesh(planeX,matHalo,MAX_STRIPS);
  const hY=new THREE.InstancedMesh(planeY,matHalo,MAX_STRIPS);
  const hZ=new THREE.InstancedMesh(planeZ,matHalo,MAX_STRIPS);

  let ixF=0,iyF=0,izF=0, ixL=0,iyL=0,izL=0, iSX=0,iSY=0,iSZ=0,iHX=0,iHY=0,iHZ=0;
  const M = new THREE.Matrix4();
  const RX=new THREE.Matrix4().makeRotationZ(Math.PI/2);
  const RY=new THREE.Matrix4().makeRotationX(Math.PI/2);
  const RZ=new THREE.Matrix4().makeRotationY(Math.PI/2);

  for(let gx=-count; gx<=count; gx++)
  for(let gy=-count; gy<=count; gy++)
  for(let gz=-count; gz<=count; gz++){
    const cx=gx*cell, cy=1.6+gy*cell, cz=gz*cell;
    if (Math.hypot(cx,cy-1.6,cz) < distance + cell*0.45) continue;

    // –ö–∞—Ä–∫–∞—Å
    [[cx, cy - half, cz - half],[cx, cy - half, cz + half],[cx, cy + half, cz - half],[cx, cy + half, cz + half]].forEach(p=>{M.identity().setPosition(...p); frameX.setMatrixAt(ixF++,M);});
    [[cx - half, cy, cz - half],[cx + half, cy, cz - half],[cx - half, cy, cz + half],[cx + half, cy, cz + half]].forEach(p=>{M.identity().setPosition(...p); frameY.setMatrixAt(iyF++,M);});
    [[cx - half, cy - half, cz],[cx + half, cy - half, cz],[cx - half, cy + half, cz],[cx + half, cy + half, cz]].forEach(p=>{M.identity().setPosition(...p); frameZ.setMatrixAt(izF++,M);});

    // —Ä–µ–¥–∫–∏–µ —Ç–æ–Ω–∫–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –±—Ä—É—Å–∫–∏ (—Å—Ç—Ä—É–∫—Ç—É—Ä–∞)
    const inner=2; const step=cell/(inner+1);
    for(let i=1;i<=inner;i++){
      const d=-half+i*step;
      [[cx,cy,cz+d],[cx,cy,cz-d]].forEach(p=>{M.identity().setPosition(...p); lineX.setMatrixAt(ixL++,M);});
      [[cx,cy+d,cz],[cx,cy-d,cz]].forEach(p=>{M.identity().setPosition(...p); lineZ.setMatrixAt(izL++,M);});
      [[cx+d,cy,cz],[cx-d,cy,cz]].forEach(p=>{M.identity().setPosition(...p); lineY.setMatrixAt(iyL++,M);});
    }

    // –ü–æ–ª–æ—Å—ã: –Ω–µ–º–Ω–æ–≥–æ, —Å–ª—É—á–∞–π–Ω–æ; —à–∞–Ω—Å –ø–æ—è–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º fillProb
    for(let a=0;a<planesPerAxis;a++){
      if(Math.random()<fillProb){ M.identity().multiply(RX).setPosition(cx, cy, cz + (Math.random()*2-1)*half); sX.setMatrixAt(iSX++,M); hX.setMatrixAt(iHX++,M); }
      if(Math.random()<fillProb){ M.identity().multiply(RY).setPosition(cx + (Math.random()*2-1)*half, cy, cz); sY.setMatrixAt(iSY++,M); hY.setMatrixAt(iHY++,M); }
      if(Math.random()<fillProb){ M.identity().multiply(RZ).setPosition(cx, cy + (Math.random()*2-1)*half, cz); sZ.setMatrixAt(iSZ++,M); hZ.setMatrixAt(iHZ++,M); }
    }
  }

  frameX.count=ixF; frameY.count=iyF; frameZ.count=izF;
  lineX.count =ixL; lineY.count =iyL; lineZ.count =izL;
  sX.count=iSX; sY.count=iSY; sZ.count=iSZ; hX.count=iHX; hY.count=iHY; hZ.count=iHZ;

  [frameX,frameY,frameZ,lineX,lineY,lineZ,sX,sY,sZ,hX,hY,hZ].forEach(im=>{
    im.instanceMatrix.needsUpdate=true; group.add(im);
  });

  group.userData.tick=(t)=>{
    group.position.z = Math.sin(t*0.45 + phase)*0.18;
    const s = 1.00 + 0.02*Math.sin(t*0.6 + phase);
    group.scale.set(1.00, s, 1.00/s);
  };
  return group;
}

/* —Å–±–æ—Ä–∫–∞ —Å—Ü–µ–Ω—ã */
let root=null;
function rebuild(){
  if(root){ scene.remove(root); root.traverse(o=>{ if(o.dispose) o.dispose(); }); root=null; }
  const P = qualityParams(pickQuality());
  root = new THREE.Group();
  const L = Math.max(2, P.layers||2);
  for(let i=0;i<L;i++) root.add( buildLayer(P, i*1.2, 0.92 + i*0.06) );
  scene.add(root);
}
document.getElementById('qsel').addEventListener('change', rebuild);

/* –º—É–∑—ã–∫–∞ */
const MUSIC_PATH='./assets/music/universe.mp3';
let audioCtx=null,musicNode=null,musicGain=null,musicStarted=false,musicMuted=false;
async function ensureMusic(){
  try{
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    if(musicStarted) return;
    const resp=await fetch(MUSIC_PATH); const buf=await resp.arrayBuffer();
    const audioBuf=await audioCtx.decodeAudioData(buf);
    musicGain=audioCtx.createGain(); musicGain.gain.value=0.0001;
    musicNode=audioCtx.createBufferSource(); musicNode.buffer=audioBuf; musicNode.loop=true;
    musicNode.connect(musicGain).connect(audioCtx.destination); musicNode.start();
    const t=audioCtx.currentTime; musicGain.gain.exponentialRampToValueAtTime(0.08, t+2.0);
    musicStarted=true; updateMuteUI();
  }catch(e){ console.warn('–ú—É–∑—ã–∫–∞ –Ω–µ —Å—Ç–∞—Ä—Ç–∞–Ω—É–ª–∞:',e); }
}
function setMuted(m){ musicMuted=m; if(musicGain){ const t=audioCtx.currentTime; musicGain.gain.cancelScheduledValues(t); musicGain.gain.exponentialRampToValueAtTime(m?0.0001:0.08, t+0.25);} updateMuteUI();}
function toggleMute(){ setMuted(!musicMuted); }
function updateMuteUI(){ document.getElementById('mute').textContent = musicMuted ? 'üîá –ë–µ–∑ –∑–≤—É–∫–∞' : 'üîä –ú—É–∑—ã–∫–∞'; }

/* –º–µ–Ω—é/VR/—Ü–∏–∫–ª */
const loading=document.getElementById('loading');
const menu=document.getElementById('menu');
requestAnimationFrame(()=>{ rebuild(); loading.style.display='none'; menu.style.display='flex'; });

renderer.xr.addEventListener('sessionstart', ()=>{
  controls.enabled=false; screen.show(); xrFadePending=true; xrFrames=0; ensureMusic();
});
document.getElementById('btnVR').onclick = async ()=>{ menu.style.display='none'; screen.show(); await startXR(); };
document.getElementById('btnSpectate').onclick = ()=>{ menu.style.display='none'; controls.enabled=true; screen.show(); ensureMusic(); setTimeout(()=>screen.fade(700),150); };
document.getElementById('mute').onclick = ()=>{ ensureMusic().then(()=>toggleMute()); };

renderer.setAnimationLoop(()=>{
  const now=performance.now()*0.001;
  if (renderer.xr.isPresenting && xrFadePending){ xrFrames++; if(xrFrames>=4){ screen.fade(700); xrFadePending=false; } }
  if(root && root.userData.tick) root.userData.tick(now);
  if(controls.enabled) controls.update();
  renderer.render(scene,camera);
});

async function startXR(){
  if(!navigator.xr){ alert('WebXR –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –û—Ç–∫—Ä–æ–π –≤ Quest Browser.'); return; }
  try{ const s=await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor','bounded-floor']}); await renderer.xr.setSession(s); }
  catch(e){ console.error(e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å VR-—Å–µ—Å—Å–∏—é.'); }
}

addEventListener('click', ()=>{ ensureMusic(); });
addEventListener('touchstart', ()=>{ ensureMusic(); }, {passive:true});
addEventListener('keydown', e=>{ if(e.code==='KeyM'){ ensureMusic().then(()=>toggleMute()); } });
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
</script>
</body>
</html>
