<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>–¢–µ—Å—Å–µ—Ä–∞–∫—Ç ‚Äî –±—ã—Å—Ç—Ä—ã–π</title>
<script src="./assets/js/three.min.js"></script>
<script src="./assets/js/OrbitControls.js"></script>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;z-index:30}
  .menu{position:fixed;inset:0;background:rgba(0,0,0,.88);display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;z-index:20}
  .btn{appearance:none;border:0;padding:12px 16px;border-radius:12px;font-weight:600;cursor:pointer;font-size:15px;background:#14b8a6;color:#00100e;box-shadow:0 4px 20px rgba(0,0,0,.35)}
  .btn.secondary{background:#1f2937;color:#cbd5e1}
  .hud{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;font-size:13px;z-index:5}
  .mute{position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2);padding:8px 10px;border-radius:10px;font-size:13px;z-index:6;cursor:pointer}
  .quality{position:fixed;right:12px;top:12px;background:rgba(0,0,0,.5);border:1px solid rgba(255,255,255,.2);padding:6px 8px;border-radius:10px;font-size:13px;z-index:7}
</style>
</head>
<body>
  <div id="loading" class="overlay"><div>–°–æ–±–∏—Ä–∞—é —Ç–µ—Å—Å–µ—Ä–∞–∫—Ç‚Ä¶</div></div>
  <div id="menu" class="menu">
    <button id="btnVR" class="btn">–í–æ–π—Ç–∏ –≤ VR</button>
    <button id="btnSpectate" class="btn secondary">–†–µ–∂–∏–º –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª—è</button>
  </div>
  <div class="hud">–ü–ö: –º—ã—à—å ‚Äî –æ–±–∑–æ—Ä. –ö–ª–∏–∫ –≤–∫–ª—é—á–∞–µ—Ç –º—É–∑—ã–∫—É. –ö–∞–º–µ—Ä–∞ –Ω–µ —Ç—Ä—è—Å—ë—Ç—Å—è.</div>
  <button id="mute" class="mute">üîä –ú—É–∑—ã–∫–∞</button>
  <div class="quality">
    –ö–∞—á–µ—Å—Ç–≤–æ:
    <select id="qsel">
      <option value="auto">auto</option>
      <option value="low">low</option>
      <option value="med">med</option>
      <option value="high">high</option>
    </select>
  </div>

<script>
/*** –î–ï–¢–ï–ö–¢ –£–°–¢–†–û–ô–°–¢–í–ê ***/
const ua = navigator.userAgent;
const isQuest = /Quest|Oculus/i.test(ua);
const isMobile = /Android|iPhone|iPad|iPod|Quest|Oculus/i.test(ua);

/*** –°–¶–ï–ù–ê ***/
const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace; else renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.5;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
// –ª—ë–≥–∫–∞—è –¥—ã–º–∫–∞ ‚Äî –≤—ã–∫–ª—é—á–∞–µ–º –Ω–∞ —à–ª–µ–º–∞—Ö —Ä–∞–¥–∏ FPS
if (!isQuest) scene.fog = new THREE.FogExp2(0x000000, 0.028);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 1500);
camera.position.set(0,1.6,0.01);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enabled = false; controls.target.set(0,1.6,0);

/*** VR-—Ñ–µ–π–¥, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å —á—ë—Ä–Ω—ã–π —ç–∫—Ä–∞–Ω –ø—Ä–∏ –≤—Ö–æ–¥–µ ***/
function makeFade(){const g=new THREE.PlaneGeometry(2,2),m=new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:1,depthTest:false});
const q=new THREE.Mesh(g,m);q.renderOrder=9999;q.position.z=-0.3;camera.add(q);scene.add(camera);
return{show:()=>m.opacity=1,fade:(ms=700)=>{const t0=performance.now();(function f(t){const k=Math.min(1,(t-t0)/ms);m.opacity=1-k;if(k<1)requestAnimationFrame(f)})(t0)}}}
const screen = makeFade(); let xrFadePending=false, xrFrames=0;

/*** –°–í–ï–¢ (–º–∏–Ω–∏–º—É–º) ***/
scene.add(new THREE.AmbientLight(0x1a1510, 0.9));
const key = new THREE.DirectionalLight(0xffe0b5, 0.5); key.position.set(-2.5,5,-4.5); scene.add(key);

/*** –ú–ê–¢–ï–†–ò–ê–õ–´ (–ø—Ä–æ—Å—Ç—ã–µ, –¥–µ—à—ë–≤—ã–µ) ***/
const woodCol = new THREE.Color(0x3c2f24);
const glassCol= new THREE.Color(0xcfd9ff);
const matWood  = new THREE.MeshLambertMaterial({color: woodCol});
const matGlass = new THREE.MeshLambertMaterial({color: glassCol, transparent:true, opacity:0.32});
const matGlow  = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, depthWrite:false});

/*** –ö–ê–ß–ï–°–¢–í–û ***/
function pickQuality(){
  const v = document.getElementById('qsel').value;
  if (v!=='auto') return v;
  if (isQuest) return 'low';
  return isMobile ? 'med' : 'high';
}

/*** –ì–ï–û: –∏–Ω—Å—Ç–∞–Ω—Å–∏–Ω–≥ –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ draw calls ***/
function buildTesseract(params){
  const {cell,count,beam,slat,emptyRadius,glassRatio,fillDensity,glowCount} = params;

  const group = new THREE.Group();

  // –±–∞–∑–æ–≤—ã–µ —Ñ–æ—Ä–º—ã
  const geoX = new THREE.BoxGeometry(cell, beam, beam);
  const geoY = new THREE.BoxGeometry(beam, cell, beam);
  const geoZ = new THREE.BoxGeometry(beam, beam, cell);
  const geoLineX = new THREE.BoxGeometry(cell, slat, slat);
  const geoLineY = new THREE.BoxGeometry(slat, cell, slat);
  const geoLineZ = new THREE.BoxGeometry(slat, slat, cell);
  const geoGlow   = new THREE.PlaneGeometry(0.3, 1.2);

  // –±—É—Ñ–µ—Ä—ã —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–æ–≤
  const M = new THREE.Matrix4();
  const pos = new THREE.Vector3();

  // —Å–Ω–∞—á–∞–ª–∞ –ø–æ—Å—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤ (—á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å InstancedMesh –Ω—É–∂–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞)
  let nFrameX=0,nFrameY=0,nFrameZ=0,nLineX=0,nLineY=0,nLineZ=0,nInnerFrames=0,nGlows=glowCount;
  const half = cell/2;
  const steps = fillDensity;
  const step  = cell/(steps+1);
  const innerFrameOffsets = [-cell/3, cell/3];

  for(let ix=-count; ix<=count; ix++)
  for(let iy=-count; iy<=count; iy++)
  for(let iz=-count; iz<=count; iz++){
    const cx=ix*cell, cy=1.6+iy*cell, cz=iz*cell;
    if (Math.hypot(cx,cy-1.6,cz) < emptyRadius + cell*0.5) continue;

    nFrameX+=4; nFrameY+=4; nFrameZ+=4;
    nLineX+=Math.max(0,(steps-1))*2; // —Å–∏–º–º–µ—Ç—Ä–∏—è
    nLineY+=Math.max(0,(steps-1))*2;
    nLineZ+=Math.max(0,(steps-1))*2;
    nInnerFrames+=innerFrameOffsets.length*12;
  }

  // —Å–æ–∑–¥–∞—ë–º InstancedMesh‚Äô–∏
  const frameX = new THREE.InstancedMesh(geoX, matWood,  nFrameX);
  const frameY = new THREE.InstancedMesh(geoY, matWood,  nFrameY);
  const frameZ = new THREE.InstancedMesh(geoZ, matWood,  nFrameZ);

  const lineX  = new THREE.InstancedMesh(geoLineX, matWood, nLineX);
  const lineY  = new THREE.InstancedMesh(geoLineY, matWood, nLineY);
  const lineZ  = new THREE.InstancedMesh(geoLineZ, matWood, nLineZ);

  const iFrame = new THREE.InstancedMesh(new THREE.BoxGeometry(cell, beam*0.7, beam*0.7), matGlass, nInnerFrames); // –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é + –ø–æ–≤–æ—Ä–æ—Ç—ã

  // –∑–∞–ø–æ–ª–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º—ã
  let ixF=0,iyF=0,izF=0, ixL=0,iyL=0,izL=0, iIF=0;

  for(let ix=-count; ix<=count; ix++)
  for(let iy=-count; iy<=count; iy++)
  for(let iz=-count; iz<=count; iz++){
    const cx=ix*cell, cy=1.6+iy*cell, cz=iz*cell;
    if (Math.hypot(cx,cy-1.6,cz) < emptyRadius + cell*0.5) continue;

    // === –∫–∞—Ä–∫–∞—Å (12 —Ä—ë–±–µ—Ä)
    // X
    M.identity().setPosition(cx, cy - half, cz - half); frameX.setMatrixAt(ixF++, M);
    M.identity().setPosition(cx, cy - half, cz + half); frameX.setMatrixAt(ixF++, M);
    M.identity().setPosition(cx, cy + half, cz - half); frameX.setMatrixAt(ixF++, M);
    M.identity().setPosition(cx, cy + half, cz + half); frameX.setMatrixAt(ixF++, M);
    // Y
    M.identity().setPosition(cx - half, cy, cz - half); frameY.setMatrixAt(iyF++, M);
    M.identity().setPosition(cx + half, cy, cz - half); frameY.setMatrixAt(iyF++, M);
    M.identity().setPosition(cx - half, cy, cz + half); frameY.setMatrixAt(iyF++, M);
    M.identity().setPosition(cx + half, cy, cz + half); frameY.setMatrixAt(iyF++, M);
    // Z
    M.identity().setPosition(cx - half, cy - half, cz); frameZ.setMatrixAt(izF++, M);
    M.identity().setPosition(cx + half, cy - half, cz); frameZ.setMatrixAt(izF++, M);
    M.identity().setPosition(cx - half, cy + half, cz); frameZ.setMatrixAt(izF++, M);
    M.identity().setPosition(cx + half, cy + half, cz); frameZ.setMatrixAt(izF++, M);

    // === –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ä–µ–π–∫–∏
    for(let i=1;i<=steps;i++){
      const d = -half + i*step;
      if (Math.abs(d) <= 0.001) continue;

      // –≤–¥–æ–ª—å X (—Ä–∞—Å–∫–ª–∞–¥ –ø–æ Z)
      M.identity().setPosition(cx, cy, cz + d); lineX.setMatrixAt(ixL++, M);
      M.identity().setPosition(cx, cy, cz - d); lineX.setMatrixAt(ixL++, M);

      // –≤–¥–æ–ª—å Z (—Ä–∞—Å–∫–ª–∞–¥ –ø–æ Y)
      M.identity().setPosition(cx, cy + d, cz); lineZ.setMatrixAt(izL++, M);
      M.identity().setPosition(cx, cy - d, cz); lineZ.setMatrixAt(izL++, M);

      // –≤–¥–æ–ª—å Y (—Ä–∞—Å–∫–ª–∞–¥ –ø–æ X)
      M.identity().setPosition(cx + d, cy, cz); lineY.setMatrixAt(iyL++, M);
      M.identity().setPosition(cx - d, cy, cz); lineY.setMatrixAt(iyL++, M);
    }

    // === –º–∏–Ω–∏-—Ä–∞–º–∫–∏ (12√óoff‚Äô–æ–≤)
    for (const off of [-cell/3, cell/3]){
      // –ø–∞—Ä–∞–ª–ª–µ–ª—å XY (—Å–¥–≤–∏–≥ –ø–æ Z)
      M.identity().setPosition(cx, cy - half, cz + off); iFrame.setMatrixAt(iIF++, M);
      M.identity().setPosition(cx, cy + half, cz + off); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationZ(Math.PI/2).setPosition(cx - half, cy, cz + off); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationZ(Math.PI/2).setPosition(cx + half, cy, cz + off); iFrame.setMatrixAt(iIF++, M);

      // –ø–∞—Ä–∞–ª–ª–µ–ª—å XZ (—Å–¥–≤–∏–≥ –ø–æ Y)
      M.identity().setPosition(cx, cy + off, cz - half); iFrame.setMatrixAt(iIF++, M);
      M.identity().setPosition(cx, cy + off, cz + half); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx - half, cy + off, cz); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx + half, cy + off, cz); iFrame.setMatrixAt(iIF++, M);

      // –ø–∞—Ä–∞–ª–ª–µ–ª—å YZ (—Å–¥–≤–∏–≥ –ø–æ X)
      M.identity().makeRotationZ(Math.PI/2).setPosition(cx + off, cy - half, cz); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationZ(Math.PI/2).setPosition(cx + off, cy + half, cz); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx + off, cy, cz - half); iFrame.setMatrixAt(iIF++, M);
      M.identity().makeRotationX(Math.PI/2).setPosition(cx + off, cy, cz + half); iFrame.setMatrixAt(iIF++, M);
    }
  }

  frameX.instanceMatrix.needsUpdate=true;
  frameY.instanceMatrix.needsUpdate=true;
  frameZ.instanceMatrix.needsUpdate=true;
  lineX.instanceMatrix.needsUpdate=true;
  lineY.instanceMatrix.needsUpdate=true;
  lineZ.instanceMatrix.needsUpdate=true;
  iFrame.instanceMatrix.needsUpdate=true;

  group.add(frameX,frameY,frameZ,lineX,lineY,lineZ,iFrame);

  // —Å–≤–µ—Ç—è—â–∏–µ—Å—è —â–µ–ª–∏ (–Ω–µ–º–Ω–æ–≥–æ, —Ç–æ–∂–µ –∏–Ω—Å—Ç–∞–Ω—Å–∏–Ω–≥)
  const glows = new THREE.InstancedMesh(geoGlow, matGlow, glowCount);
  for(let i=0;i<glowCount;i++){
    const ax=(Math.random()*3)|0;
    const ring = (Math.random()*(count*2+1)|0)-(count);
    const base = ring*cell;
    const h=half;
    let x=0,y=1.6,z=0,rx=0,ry=0,rz=0;
    if(ax===0){ x=0; y=1.6+(Math.random()*2-1)*h; z=(Math.random()<.5?-1:1)*h + base; ry=Math.PI/2; }
    if(ax===1){ x=(Math.random()<.5?-1:1)*h + base; y=1.6; z=(Math.random()*2-1)*h; rx=Math.PI/2; }
    if(ax===2){ x=(Math.random()*2-1)*h + base; y=1.6+(Math.random()<.5?-1:1)*h; z=0; }
    M.identity().makeRotationFromEuler(new THREE.Euler(rx,ry,rz)).setPosition(x,y,z);
    glows.setMatrixAt(i,M);
  }
  glows.instanceMatrix.needsUpdate=true;
  group.add(glows);

  // –ª—ë–≥–∫–æ–µ ¬´–¥—ã—Ö–∞–Ω–∏–µ¬ª
  group.userData.update=(dt,t)=>{
    group.rotation.y = Math.sin(t*0.03)*0.05;
    group.position.x = Math.sin(t*0.05+1.2)*0.18;
    group.position.z = Math.sin(t*0.06)*0.22;
  };
  return group;
}

/*** –ü–†–û–§–ò–õ–ò –ö–ê–ß–ï–°–¢–í–ê ***/
function qualityParams(q){
  if(q==='low')  return {cell:3, count:2, beam:0.085, slat:0.024, emptyRadius:1.6, glassRatio:0.3, fillDensity:5, glowCount:120};
  if(q==='med')  return {cell:3, count:3, beam:0.09,  slat:0.024, emptyRadius:1.6, glassRatio:0.35,fillDensity:7, glowCount:180};
  /* high */
  return             {cell:3, count:3, beam:0.10, slat:0.022, emptyRadius:1.6, glassRatio:0.35,fillDensity:10,glowCount:240};
}

/*** –°–ë–û–†–ö–ê ***/
let grid=null;
function rebuild(){
  if(grid){ scene.remove(grid); grid.traverse(o=>{ if(o.dispose) o.dispose(); }); grid=null; }
  const q = pickQuality();
  const p = qualityParams(q);
  grid = buildTesseract(p);
  scene.add(grid);
}
document.getElementById('qsel').value='auto';
document.getElementById('qsel').addEventListener('change', ()=>{ rebuild(); });

/*** –ú–£–ó–´–ö–ê ***/
const MUSIC_PATH = './assets/music/universe.mp3';
let audioCtx=null, musicNode=null, musicGain=null, musicStarted=false, musicMuted=false;
async function ensureMusic(){
  try{
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    if(musicStarted) return;
    const resp=await fetch(MUSIC_PATH); const buf=await resp.arrayBuffer();
    const audioBuf=await audioCtx.decodeAudioData(buf);
    musicGain=audioCtx.createGain(); musicGain.gain.value=0.0001;
    musicNode=audioCtx.createBufferSource(); musicNode.buffer=audioBuf; musicNode.loop=true;
    musicNode.connect(musicGain).connect(audioCtx.destination); musicNode.start();
    const t=audioCtx.currentTime; musicGain.gain.exponentialRampToValueAtTime(0.10, t+2.0);
    musicStarted=true; updateMuteUI();
  }catch(e){ console.warn('–ú—É–∑—ã–∫–∞ –Ω–µ —Å—Ç–∞—Ä—Ç–∞–Ω—É–ª–∞:',e); }
}
function setMuted(m){ musicMuted=m; if(musicGain){ const t=audioCtx.currentTime; musicGain.gain.cancelScheduledValues(t); musicGain.gain.exponentialRampToValueAtTime(m?0.0001:0.10, t+0.25);} updateMuteUI();}
function toggleMute(){ setMuted(!musicMuted); }
function updateMuteUI(){ document.getElementById('mute').textContent = musicMuted ? 'üîá –ë–µ–∑ –∑–≤—É–∫–∞' : 'üîä –ú—É–∑—ã–∫–∞'; }

/*** –ú–ï–ù–Æ / VR ***/
const loading=document.getElementById('loading');
const menu=document.getElementById('menu');
requestAnimationFrame(()=>{ rebuild(); loading.style.display='none'; menu.style.display='flex'; });

renderer.xr.addEventListener('sessionstart', ()=>{
  controls.enabled=false; screen.show(); xrFadePending=true; xrFrames=0; ensureMusic();
});
document.getElementById('btnVR').onclick = async ()=>{ menu.style.display='none'; screen.show(); await startXR(); };
document.getElementById('btnSpectate').onclick = ()=>{ menu.style.display='none'; controls.enabled=true; screen.show(); ensureMusic(); setTimeout(()=>screen.fade(700),150); };
document.getElementById('mute').onclick = ()=>{ ensureMusic().then(()=>toggleMute()); };

/*** –¶–ò–ö–õ ***/
let last=performance.now()*0.001;
renderer.setAnimationLoop(()=>{
  const now=performance.now()*0.001, dt=Math.min(0.033, now-last); last=now;
  if (renderer.xr.isPresenting && xrFadePending){ xrFrames++; if(xrFrames>=4){ screen.fade(700); xrFadePending=false; } }
  if(grid && grid.userData.update) grid.userData.update(dt, now);
  if(controls.enabled) controls.update();
  renderer.render(scene,camera);
});

/*** XR ***/
async function startXR(){
  if(!navigator.xr){ alert('WebXR –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –û—Ç–∫—Ä–æ–π –≤ Quest Browser.'); return; }
  try{ const s=await navigator.xr.requestSession('immersive-vr',{optionalFeatures:['local-floor','bounded-floor']}); await renderer.xr.setSession(s); }
  catch(e){ console.error(e); alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å VR-—Å–µ—Å—Å–∏—é.'); }
}

/*** INPUT / RESIZE ***/
addEventListener('click', ()=>{ ensureMusic(); });
addEventListener('touchstart', ()=>{ ensureMusic(); }, {passive:true});
addEventListener('keydown', e=>{ if(e.code==='KeyM'){ ensureMusic().then(()=>toggleMute()); } });
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

</script>
</body>
</html>
