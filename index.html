<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Комната — портал с прогрессом</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }
    #overlay, #loading-screen {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: radial-gradient(circle at center, rgba(0,0,0,.85), rgba(0,0,0,1));
      color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      z-index: 9999;
    }
    #overlay button {
      font-size: 18px; padding: 14px 24px; border-radius: 12px; border: none;
      background: #ffb366; color: #000; cursor: pointer; transition: transform .2s, background .3s;
    }
    #overlay button:hover { transform: scale(1.05); background: #ffd5a3; }

    .portal-wrap { display:flex; flex-direction:column; align-items:center; gap:14px; }
    .portal-text { font-size: 1.1rem; letter-spacing: .5px; text-align:center; }
    .portal-ring {
      width: 72px; height: 72px;
      border: 4px solid rgba(255,200,100,.45); border-top-color:#ffb366; border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    .bar { width: 260px; height: 8px; background: rgba(255,255,255,.12); border-radius:8px; overflow:hidden; }
    .bar-fill { height:100%; width:0%; background:#ffb366; transition: width .15s ease; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .fade-out { animation: fadeOut 1s forwards; }
    @keyframes fadeOut { to { opacity: 0; visibility: hidden; } }
  </style>
</head>
<body>
  <div id="overlay"><button id="start">Войти в комнату</button></div>

  <div id="loading-screen" style="display:none;">
    <div class="portal-wrap">
      <div class="portal-text">Переносимся через портал… <span id="progress">0%</span></div>
      <div class="bar"><div id="bar-fill" class="bar-fill"></div></div>
      <div class="portal-ring"></div>
    </div>
  </div>

  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>

  <script>
    // ---------- СЦЕНА/РЕНДЕР ----------
    let scene, camera, renderer, controls, listener, bgm, portalSound;
    const w = 4, d = 4, h = 3; // размеры комнаты

    // Настраиваемые размеры моделей (чтобы «не были гигантами»)
    const CHEST_TARGET_DIAG = 1.0;    // м — «диагональ» сундука после нормализации
    const BARREL_RELATIVE    = 0.80;   // от размера сундука (0.8 = чуть меньше сундука)
    const BARREL_Z_OFFSET    = -0.70;  // сдвиг бочки по Z относительно сундука (вдоль стены)
    const WALL_OFFSET_X      = 0.45;   // отступ от левой стены для обеих моделей

    function playPortal() {
      try {
        const loader = new THREE.AudioLoader();
        portalSound = new THREE.Audio(listener);
        loader.load('assets/music/portal.mp3', (buffer) => {
          portalSound.setBuffer(buffer); portalSound.setLoop(false);
          portalSound.setVolume(0.9); portalSound.play();
        });
      } catch (e) { console.warn('portal.mp3 не найден'); }
    }
    function startBGM() {
      try {
        const ac = listener?.context; if (ac && ac.state === 'suspended') ac.resume();
        const loader = new THREE.AudioLoader();
        bgm = new THREE.Audio(listener);
        loader.load('assets/music/music.mp3', (buffer) => {
          bgm.setBuffer(buffer); bgm.setLoop(true); bgm.setVolume(0.35); bgm.play();
        }, undefined, () => console.warn('music.mp3 не найден'));
      } catch (e) { console.warn('BGM error', e); }
    }

    function init() {
      const overlay = document.getElementById('overlay');
      const loadingScreen = document.getElementById('loading-screen');
      const progressText = document.getElementById('progress');
      const barFill = document.getElementById('bar-fill');
      const startBtn = document.getElementById('start');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x100806);
      scene.fog = new THREE.Fog(0x1a0f0a, 5, 12);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 50);
      camera.position.set(0, 1.6, 2.8);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.2, 0);
      controls.enableDamping = true;

      // свет
      const hemi = new THREE.HemisphereLight(0xffd9b0, 0x1a0f0a, 0.35); scene.add(hemi);
      const ambient = new THREE.AmbientLight(0xffd7aa, 0.15); scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffb366, 1.25); dir.position.set(-2.5, 3.5, 1.5);
      dir.castShadow = true; dir.shadow.mapSize.set(2048, 2048); dir.shadow.radius = 6; scene.add(dir);
      const fire = new THREE.PointLight(0xffa860, 0.6, 6); fire.position.set(-1.5, 1.2, 1.2); scene.add(fire);

      // аудио-листенер
      listener = new THREE.AudioListener(); camera.add(listener);

      // кнопка входа -> включаем портал и начинаем загрузку ассетов
      startBtn.addEventListener('click', () => {
        overlay.style.display = 'none';
        loadingScreen.style.display = 'grid';

        loadAllAssetsWithProgress((pct) => {
          progressText.textContent = `${pct}%`;
          barFill.style.width = `${pct}%`;
        }).then(() => {
          playPortal();
          loadingScreen.classList.add('fade-out');
          setTimeout(() => {
            loadingScreen.remove();
            startBGM(); // музыка только после портала
          }, 1000);
        });
      }, { once: true });

      // resize + анимация
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      (function animate(){ requestAnimationFrame(animate);
        fire.intensity = 0.55 + Math.sin(performance.now() * 0.003) * 0.15;
        controls.update(); renderer.render(scene, camera); })();
    }

    // ---------- ЗАГРУЗКА С ПРОГРЕССОМ ----------
    function loadAllAssetsWithProgress(onProgress) {
      return new Promise((resolve) => {
        // LoadingManager даёт общий прогресс по ВСЕМ загрузкам (текстуры + модели)
        const manager = new THREE.LoadingManager(
          () => resolve(), // onLoad (всё загрузилось)
          (url, itemsLoaded, itemsTotal) => {
            const pct = Math.min(100, Math.floor(itemsLoaded / itemsTotal * 100));
            onProgress?.(pct);
          },
          (url) => {
            console.warn('Ошибка загрузки:', url);
          }
        );

        // Текстуры через manager
        const tl = new THREE.TextureLoader(manager);
        const floorTex = tl.load('assets/textures/floor.jpg');
        floorTex.colorSpace = THREE.SRGBColorSpace;
        floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
        floorTex.repeat.set(2, 2);

        const wallTex  = tl.load('assets/textures/wall.jpg?v=6');
        wallTex.colorSpace = THREE.SRGBColorSpace;
        wallTex.wrapS = wallTex.wrapT = THREE.ClampToEdgeWrapping;

        const mirrorTex = tl.load('assets/textures/mirror.jpg');
        mirrorTex.colorSpace = THREE.SRGBColorSpace;

        // Комната (можно создавать сразу — текстуры подтянутся, когда догрузятся)
        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(w, d),
          new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.9 })
        );
        floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

        const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 1.0 });
        const walls = [
          [0, h/2, -d/2, 0], [0, h/2, d/2, Math.PI],
          [-w/2, h/2, 0, Math.PI/2], [w/2, h/2, 0, -Math.PI/2]
        ];
        walls.forEach(([x,y,z,ry])=>{
          const wall = new THREE.Mesh(new THREE.PlaneGeometry(ry ? d : w, h), wallMat);
          wall.position.set(x,y,z); if (ry) wall.rotation.y = ry;
          wall.receiveShadow = true; scene.add(wall);
        });

        const mirror = new THREE.Mesh(
          new THREE.PlaneGeometry(0.9, 0.6),
          new THREE.MeshStandardMaterial({ map: mirrorTex, metalness: 0.85, roughness: 0.22 })
        );
        mirror.position.set(0, 1.5, -d/2 + 0.01); scene.add(mirror);

        // Модели через manager
        const gltfLoader = new THREE.GLTFLoader(manager);

        // Сундук
        gltfLoader.load('assets/models/chest.glb', (gltf) => {
          const chest = gltf.scene;
          chest.traverse(o => { if (o.isMesh) { o.castShadow = o.receiveShadow = true; } });

          // нормализация/масштаб
          const box0 = new THREE.Box3().setFromObject(chest);
          chest.position.sub(box0.getCenter(new THREE.Vector3()));
          const diag0 = box0.getSize(new THREE.Vector3()).length();
          const s = diag0 > 0 ? (CHEST_TARGET_DIAG / diag0) : 1;
          chest.scale.setScalar(s);

          // на пол
          const box1 = new THREE.Box3().setFromObject(chest);
          chest.position.y -= box1.min.y;

          // позиция и поворот (как ты задавал)
          chest.position.set(-w/2 + WALL_OFFSET_X, 0, 1.10);
          chest.rotation.y = Math.PI;

          scene.add(chest);

          // Бочка (зависит от сундука, но тоже учитывается в общем прогрессе)
          gltfLoader.load('assets/models/barrel.glb', (gltf2) => {
            const barrel = gltf2.scene;
            barrel.traverse(o => { if (o.isMesh) { o.castShadow = o.receiveShadow = true; } });

            // нормализация
            const b0 = new THREE.Box3().setFromObject(barrel);
            barrel.position.sub(b0.getCenter(new THREE.Vector3()));

            // масштаб относительно сундука
            const chestSize = new THREE.Box3().setFromObject(chest).getSize(new THREE.Vector3()).length();
            const barrelSize = b0.getSize(new THREE.Vector3()).length();
            const rel = barrelSize > 0 ? (chestSize / barrelSize) * BARREL_RELATIVE : 1;
            barrel.scale.setScalar(rel);

            // на пол
            const b1 = new THREE.Box3().setFromObject(barrel);
            barrel.position.y -= b1.min.y;

            // справа от сундука вдоль стены
            barrel.position.x = chest.position.x;
            barrel.position.z = chest.position.z + BARREL_Z_OFFSET; // отрицательное — «назад» по стене
            barrel.rotation.y = chest.rotation.y;

            scene.add(barrel);
          }, undefined, (err)=>console.warn('Ошибка бочки', err));
        }, undefined, (err)=>console.warn('Ошибка сундука', err));

        // страховка: даже если что-то пойдёт не так, через 12с — вход
        setTimeout(()=>resolve(), 12000);
      });
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
