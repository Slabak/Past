<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Комната — фикс балок, бочки и двери</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:5;
    background:radial-gradient(ellipse at center,rgba(0,0,0,.78),rgba(0,0,0,.95));
    color:#fff;font:16px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #overlay button{padding:12px 18px;border:none;border-radius:10px;background:#ffb366;color:#000;cursor:pointer}
  .vr-btn{position:fixed;left:12px;bottom:12px;z-index:7;background:#1e1e1e;color:#fff;border:1px solid #444;border-radius:8px;padding:10px 14px;font:14px system-ui;cursor:pointer}
  .vr-btn[disabled]{opacity:.4;cursor:not-allowed}
</style>
</head>
<body>
  <div id="overlay">
    <div style="text-align:center">
      <div style="margin-bottom:12px;font-size:18px">Переносимся через портал…</div>
      <button id="enter">Войти</button>
      <div style="margin-top:10px;font-size:12px;opacity:.7">Экран и VR (Quest) поддерживаются</div>
    </div>
  </div>

  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>
<script>
/* ===== простая встроенная VR-кнопка ===== */
function createSimpleVRButton(renderer){
  const btn=document.createElement('button'); btn.className='vr-btn'; btn.textContent='Войти в VR';
  if(!('xr' in navigator)){ btn.textContent='VR не поддерживается'; btn.disabled=true; return btn; }
  let session=null;
  async function onEnd(){ session.removeEventListener('end', onEnd); session=null; btn.textContent='Войти в VR'; }
  async function onStart(s){ session=s; s.addEventListener('end', onEnd); await renderer.xr.setSession(s); btn.textContent='Выйти из VR'; }
  btn.addEventListener('click', async ()=>{
    try{
      if(!session){
        const s=await navigator.xr.requestSession('immersive-vr',{requiredFeatures:['local-floor']});
        onStart(s);
      } else { await session.end(); }
    }catch(e){ console.warn('XR error',e); }
  });
  return btn;
}

/* ===== размеры комнаты ===== */
const W=4, D=4, H=3;

/* ===== пути к ресурсам ===== */
const TEX_FLOOR='assets/textures/floor.jpg';
const TEX_WALL ='assets/textures/wall.jpg';
const TEX_CEIL ='assets/textures/potolok.jpg';

const MODEL_TABLE ='assets/models/table.glb';
const MODEL_BARREL='assets/models/barrel.glb';
const MODEL_CHEST ='assets/models/chest.glb';
const MODEL_GLOBUS='assets/models/globus.glb';
const MODEL_PLANK ='assets/models/plank.glb';
const MODEL_DOOR  ='assets/models/door.glb';

/* ===== позиции (как договаривались) ===== */
// стол — задняя стена под «зеркалом»
const POS_TABLE  = new THREE.Vector3( 0.0, 0.0, -D/2 + 0.55);
// сундук — левая стена, ближе к зрителю
const POS_CHEST_X = -W/2 + 0.45;
const POS_CHEST_Z =  1.10;
// бочка — СПРАВА от сундука ВДОЛЬ той же левой стены (двигаем по Z)
const POS_BARREL_X = POS_CHEST_X;          // тот же X, чтобы вдоль стены
const POS_BARREL_Z = POS_CHEST_Z + 0.90;   // правее (если смотришь на сундук) — вперёд по Z
// глобус — правая стена ближе к задней
const POS_GLOBUS  = new THREE.Vector3( W/2 - 0.55, 0.0, -D/2 + 0.9 );
// дверь — плоскость передней стены, утоп на 5мм
const POS_DOOR    = new THREE.Vector3( 0.0, 0.0,  D/2 - 0.005 );

/* ===== глобальные ===== */
let scene,camera,renderer,controls,loopRunning=false, tl;

/* ===== инициализация ===== */
function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x0b0706);
  scene.fog=new THREE.Fog(0x120b08,6,14);

  camera=new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 100);
  camera.position.set(0,1.6,2.8);

  renderer=new THREE.WebGLRenderer({antialias:true});
  const isMobile=/Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);
  renderer.setPixelRatio(isMobile? 1 : Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputColorSpace=THREE.SRGBColorSpace;
  renderer.toneMapping=THREE.ACESFilmicToneMapping; renderer.toneMappingExposure=1.05;
  renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap;

  renderer.xr.enabled=true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(createSimpleVRButton(renderer));

  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.target.set(0,1.2,0);
  controls.enableDamping=true; controls.enablePan=false; controls.enableZoom=false;
  controls.rotateSpeed=-0.8; controls.dampingFactor=0.12;

  tl=new THREE.TextureLoader();

  buildRoom();         // стены/пол/потолок + свет
  loadPlankBeams();    // балКИ из модели, без щелей
  loadModels();        // стол, сундук, бочка, глобус, дверь

  addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);
  });

  if(!loopRunning){
    loopRunning=true;
    renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene,camera); });
  }

  document.getElementById('enter').addEventListener('click',()=>{
    document.getElementById('overlay').style.display='none';
  },{once:true});
}

/* ===== комната ===== */
function buildRoom(){
  const floorTex=tl.load(TEX_FLOOR); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2); floorTex.colorSpace=THREE.SRGBColorSpace;
  const wallTex =tl.load(TEX_WALL ); wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping; wallTex.colorSpace=THREE.SRGBColorSpace;
  const ceilTex =tl.load(TEX_CEIL ); ceilTex.wrapS=ceilTex.wrapT=THREE.RepeatWrapping; ceilTex.repeat.set(2,2); ceilTex.colorSpace=THREE.SRGBColorSpace;

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:floorTex,roughness:.9}));
  floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

  const wallMat=new THREE.MeshStandardMaterial({map:wallTex,roughness:1});
  const back =new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); back.position.set(0,H/2,-D/2); scene.add(back);
  const front=new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); front.position.set(0,H/2, D/2); front.rotation.y=Math.PI; scene.add(front);
  const left =new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); left.position.set(-W/2,H/2,0); left.rotation.y= Math.PI/2; scene.add(left);
  const right=new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); right.position.set( W/2,H/2,0); right.rotation.y=-Math.PI/2; scene.add(right);

  const ceil=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:ceilTex,roughness:.85}));
  ceil.position.set(0,H,0); ceil.rotation.x=Math.PI/2; scene.add(ceil);

  // тёплый свет
  scene.add(new THREE.HemisphereLight(0xffdcb8,0x1b0e0a,0.38));
  scene.add(new THREE.AmbientLight(0xffe0bb,0.2));
  const dir=new THREE.DirectionalLight(0xffb06a,1.05);
  dir.position.set(-2.5,3.2,1.5); dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); dir.shadow.radius=4; scene.add(dir);
  const fire=new THREE.PointLight(0xffa860,0.58,5.0); fire.position.set(-1.4,1.15,1.1); scene.add(fire);
}

/* ===== балки из plank.glb (без щелей) ===== */
const BEAM_THICK=0.22;          // толщина балки
const BEAM_MITER_OVERLAP=0.04;  // нахлёст в стык
const POST_FLOOR_GAP=0.01;      // от пола (м)
const EPS=0.001;                // микрозазор к потолку

function loadPlankBeams(){
  const loader=new THREE.GLTFLoader();
  loader.load(MODEL_PLANK,(gltf)=>{
    const root=gltf.scene;

    function prepareUnit(src){
      const box=new THREE.Box3().setFromObject(src);
      src.position.sub(box.getCenter(new THREE.Vector3()));

      const s=box.getSize(new THREE.Vector3());
      let axis='y'; if(s.x>=s.y && s.x>=s.z) axis='x'; else if(s.z>=s.y && s.z>=s.x) axis='z';
      if(axis==='x') src.rotation.set(0,0,Math.PI/2);
      if(axis==='z') src.rotation.set(-Math.PI/2,0,0);

      const box2=new THREE.Box3().setFromObject(src), lenY=Math.max(box2.getSize(new THREE.Vector3()).y,1e-6);
      src.scale.multiplyScalar(1/lenY);

      const base=new THREE.Box3().setFromObject(src).getSize(new THREE.Vector3());
      const baseX=Math.max(base.x,1e-6), baseZ=Math.max(base.z,1e-6);

      const unit=new THREE.Group(); unit.add(src);

      function spawnBetween(a,b,th=BEAM_THICK){
        const clone=unit.clone(true);
        const dir=new THREE.Vector3().subVectors(b,a); const len=dir.length(); if(len<1e-6) return null;
        const mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
        clone.position.copy(mid);
        const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
        clone.quaternion.copy(q);
        clone.scale.set(th/baseX, len + BEAM_MITER_OVERLAP*2, th/baseZ);
        clone.traverse(o=>{ if(o.isMesh){ o.castShadow=false; o.receiveShadow=false; }});
        scene.add(clone);
        return clone;
      }
      return {spawnBetween};
    }

    const {spawnBetween}=prepareUnit(root);

    const half=BEAM_THICK*0.5;
    const xL = -W/2 + half;
    const xR =  W/2 - half;
    const zB = -D/2 + half; // задняя
    const zF =  D/2 - half; // передняя

    // верт. стойки: от пола +POST_FLOOR_GAP до потолка - EPS
    const yBottom = POST_FLOOR_GAP + half;
    const yTop    = H - EPS - half;

    // гор. под потолком: центр на высоте H - half - EPS
    const yHoriz  = H - EPS - half;

    // 4 вертикальные
    spawnBetween(new THREE.Vector3(xL,yBottom,zB), new THREE.Vector3(xL,yTop,zB));
    spawnBetween(new THREE.Vector3(xR,yBottom,zB), new THREE.Vector3(xR,yTop,zB));
    spawnBetween(new THREE.Vector3(xL,yBottom,zF), new THREE.Vector3(xL,yTop,zF));
    spawnBetween(new THREE.Vector3(xR,yBottom,zF), new THREE.Vector3(xR,yTop,zF));

    // 4 горизонтальные под потолком (периметр), с нахлёстом
    spawnBetween(new THREE.Vector3(xL - BEAM_MITER_OVERLAP, yHoriz, zB),
                 new THREE.Vector3(xR + BEAM_MITER_OVERLAP, yHoriz, zB));
    spawnBetween(new THREE.Vector3(xL - BEAM_MITER_OVERLAP, yHoriz, zF),
                 new THREE.Vector3(xR + BEAM_MITER_OVERLAP, yHoriz, zF));
    spawnBetween(new THREE.Vector3(xL, yHoriz, zB - BEAM_MITER_OVERLAP),
                 new THREE.Vector3(xL, yHoriz, zF + BEAM_MITER_OVERLAP));
    spawnBetween(new THREE.Vector3(xR, yHoriz, zB - BEAM_MITER_OVERLAP),
                 new THREE.Vector3(xR, yHoriz, zF + BEAM_MITER_OVERLAP));
  }, undefined, (e)=>console.warn('Ошибка plank.glb', e));
}

/* ===== загрузка мебели/декора/двери ===== */
function loadModels(){
  const L=new THREE.GLTFLoader();

  function fitByHeight(root, targetH){
    root.traverse(o=>{ if(o.isMesh){o.castShadow=o.receiveShadow=true; }});
    const b=new THREE.Box3().setFromObject(root);
    const h=b.getSize(new THREE.Vector3()).y||1;
    const k=targetH/h;
    root.scale.setScalar(k);
    const b2=new THREE.Box3().setFromObject(root);
    root.position.sub(b2.getCenter(new THREE.Vector3()));
    const b3=new THREE.Box3().setFromObject(root);
    root.position.y -= b3.min.y; // на пол
  }

  // СТОЛ ~ 0.78 м
  L.load(MODEL_TABLE,(g)=>{
    const m=g.scene; fitByHeight(m, 0.78);
    m.position.copy(POS_TABLE);
    scene.add(m);
  });

  // СУНДУК — как раньше (по диагонали ×1.5)
  L.load(MODEL_CHEST,(g)=>{
    const chest=g.scene;
    chest.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; } });

    const box0=new THREE.Box3().setFromObject(chest);
    chest.position.sub(box0.getCenter(new THREE.Vector3()));

    const SIZE_MULT=1.5;
    const targetDiag=1.2*SIZE_MULT;
    const diag0=box0.getSize(new THREE.Vector3()).length();
    const s=diag0>0 ? targetDiag/diag0 : 1;
    chest.scale.setScalar(s);

    const box1=new THREE.Box3().setFromObject(chest);
    chest.position.y -= box1.min.y;

    chest.position.x = POS_CHEST_X;
    chest.position.z = POS_CHEST_Z;
    chest.rotation.y = Math.PI;

    scene.add(chest);
  });

  // БОЧКА ~ 1.0 м — СПРАВА от сундука вдоль ЛЕВОЙ стены (тот же X, другой Z)
  L.load(MODEL_BARREL,(g)=>{
    const m=g.scene; fitByHeight(m, 1.00);
    m.position.set(POS_BARREL_X, 0, POS_BARREL_Z);
    m.rotation.y=Math.PI; // идём вдоль стены — ориентация как у сундука
    scene.add(m);
  });

  // ГЛОБУС ~ 1.2 м — правая стена
  L.load(MODEL_GLOBUS,(g)=>{
    const m=g.scene; fitByHeight(m, 1.20);
    m.position.copy(POS_GLOBUS);
    m.rotation.y=-Math.PI/2;
    scene.add(m);
  });

  // ДВЕРЬ ~ 2.1 м — АВТО-ориентация в плоскость стены + утоп
  L.load(MODEL_DOOR,(g)=>{
    const m=g.scene; fitByHeight(m, 2.10);

    // Подберём поворот по Y так, чтобы толщина была по оси Z (минимальная Z)
    const rotations=[0, Math.PI/2, Math.PI, -Math.PI/2];
    let bestR = 0, bestZ = Infinity;
    rotations.forEach(r=>{
      m.rotation.set(0,r,0);
      const bb=new THREE.Box3().setFromObject(m);
      const size=bb.getSize(new THREE.Vector3());
      if(size.z < bestZ){ bestZ=size.z; bestR=r; }
    });
    m.rotation.set(0,bestR,0);

    // ставим в плоскость передней стены, утопляем на 5 мм
    m.position.copy(POS_DOOR);
    scene.add(m);
  });
}

/* ===== старт ===== */
window.addEventListener('load', init);
</script>
</body>
</html>
