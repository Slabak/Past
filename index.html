<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Комната — портал, 360° камера, сундук, бочки и балки</title>
  <style>
    html, body { height:100%; margin:0; overflow:hidden; background:#000; }
    #overlay, #loading-screen {
      position:fixed; inset:0; display:grid; place-items:center;
      background:radial-gradient(circle at center, rgba(0,0,0,.85), rgba(0,0,0,1));
      color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; z-index:9999;
    }
    #overlay button {
      font-size:18px; padding:14px 24px; border-radius:12px; border:none;
      background:#ffb366; color:#000; cursor:pointer; transition:transform .2s,background .3s;
    }
    #overlay button:hover { transform:scale(1.05); background:#ffd5a3; }
    .portal-wrap { display:flex; flex-direction:column; align-items:center; gap:14px; }
    .portal-text { font-size:1.1rem; letter-spacing:.5px; text-align:center; }
    .portal-ring { width:72px; height:72px; border:4px solid rgba(255,200,100,.45);
      border-top-color:#ffb366; border-radius:50%; animation:spin 1s linear infinite; }
    .bar { width:260px; height:8px; background:rgba(255,255,255,.12); border-radius:8px; overflow:hidden; }
    .bar-fill { height:100%; width:0%; background:#ffb366; transition:width .15s ease; }
    @keyframes spin { to { transform:rotate(360deg); } }
    .fade-out { animation:fadeOut 1s forwards; }
    @keyframes fadeOut { to { opacity:0; visibility:hidden; } }

    #modeToggle {
      position: fixed; top: 14px; right: 14px; z-index: 10000;
      background: rgba(0,0,0,.55); color: #fff; border:1px solid rgba(255,255,255,.2);
      padding: 10px 12px; border-radius: 10px; font-size: 14px; cursor: pointer;
      backdrop-filter: blur(6px); display: none;
    }
    #toast {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 16px; padding: 10px 14px; border-radius: 10px; color: #000;
      background: #ffd48a; z-index: 10000; font-size: 14px; display: none;
    }
  </style>
</head>
<body>
  <div id="overlay"><button id="start">Войти в комнату</button></div>

  <div id="loading-screen" style="display:none;">
    <div class="portal-wrap">
      <div class="portal-text">Переносимся через портал… <span id="progress">0%</span></div>
      <div class="bar"><div id="bar-fill" class="bar-fill"></div></div>
      <div class="portal-ring"></div>
    </div>
  </div>

  <button id="modeToggle">Управление: ПАЛЕЦ</button>
  <div id="toast"></div>

  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>

  <script>
    // ---- Параметры комнаты/объектов ----
    const w = 4, d = 4, h = 3; // м

    // Сундук (как договаривались)
    const CHEST_SIZE_MULT     = 1.5;
    const CHEST_WALLOFFSET_X  = 0.45;
    const CHEST_Z             = 1.10;

    // Бочки (у левого-заднего угла)
    const BARRELS_TARGET_HEIGHT = 1.30;
    const BARRELS_WALLOFFSET_X  = 0.45;
    const BARRELS_Z             = -1.10;
    const BARRELS_ROT_LEFT_90   = true;

    // БАЛКИ (plank.glb)
    const BEAM_THICKNESS     = 0.16;     // толщина/ширина ~16 см
    const BEAM_INSET_WALL    = 0.000;    // от стен
    const BEAM_INSET_CEIL    = 0.000;    // от потолка
    const POST_FLOOR_GAP     = 0.000;    // приподнять стойки от пола
    const BEAM_MITER_OVERLAP = BEAM_THICKNESS * 1.2; // заход в углы, чтобы исключить щель

    // ---- Глобальные ----
    let scene, camera, renderer;
    let orbitControls = null, deviceControls = null, activeControls = null;
    let listener, bgm, portalSound, fallbackWood = null;

    const $ = s => document.querySelector(s);
    const toast = (m,ms=2200)=>{const t=$('#toast'); t.textContent=m;t.style.display='block';clearTimeout(toast._t);toast._t=setTimeout(()=>t.style.display='none',ms);};

    // ---- Аудио ----
    function playPortal(){ try{ const l=new THREE.AudioLoader(); portalSound=new THREE.Audio(listener);
      l.load('assets/music/portal.mp3',buf=>{portalSound.setBuffer(buf);portalSound.setLoop(false);portalSound.setVolume(0.9);portalSound.play();}); }catch{} }
    function startBGM(){ try{ const ac=listener?.context; if(ac&&ac.state==='suspended') ac.resume();
      const l=new THREE.AudioLoader(); bgm=new THREE.Audio(listener);
      l.load('assets/music/music.mp3',buf=>{bgm.setBuffer(buf);bgm.setLoop(true);bgm.setVolume(0.35);bgm.play();},undefined,()=>console.warn('music.mp3 не найден')); }catch{} }

    // ---- Встроенный DeviceOrientation-контрол ----
    function makeDeviceControls(cam){
      let alphaOffset=0,last=null;
      const zee=new THREE.Vector3(0,0,1), euler=new THREE.Euler(), q0=new THREE.Quaternion(),
            q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
      let so=(window.orientation||0);
      function onSO(){so=(window.orientation||0);} function onDO(e){last=e;}
      function setQ(q,a,b,g,o){ euler.set(b,a,-g,'YXZ'); q.setFromEuler(euler); q.multiply(q1); q.multiply(q0.setFromAxisAngle(zee,-o)); }
      window.addEventListener('orientationchange', onSO, false);
      window.addEventListener('deviceorientation', onDO, true);
      return {
        update(){ if(!last) return;
          const a=THREE.MathUtils.degToRad(last.alpha||0)+alphaOffset;
          const b=THREE.MathUtils.degToRad(last.beta ||0);
          const g=THREE.MathUtils.degToRad(last.gamma||0);
          const o=THREE.MathUtils.degToRad(so||0);
          setQ(cam.quaternion,a,b,g,o);
        },
        disconnect(){ window.removeEventListener('deviceorientation', onDO, true); window.removeEventListener('orientationchange', onSO, false); },
        calibrateToCurrentHeading(){ if(!last) return; alphaOffset = -THREE.MathUtils.degToRad(last.alpha||0); }
      };
    }

    function init(){
      const overlay=$('#overlay'), loading=$('#loading-screen'), startBtn=$('#start'),
            progressText=$('#progress'), barFill=$('#bar-fill'), modeBtn=$('#modeToggle');

      scene=new THREE.Scene();
      scene.background=new THREE.Color(0x100806);
      scene.fog=new THREE.Fog(0x1a0f0a,5,12);

      camera=new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, .05, 50);
      camera.position.set(0,1.6,0);

      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled=true;
      renderer.shadowMap.type=THREE.PCFSoftShadowMap;
      renderer.outputColorSpace=THREE.SRGBColorSpace;
      renderer.toneMapping=THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure=1.05;
      document.body.appendChild(renderer.domElement);

      const hemi=new THREE.HemisphereLight(0xffd9b0,0x1a0f0a,0.35); scene.add(hemi);
      const ambient=new THREE.AmbientLight(0xffd7aa,0.22); scene.add(ambient);
      const dir=new THREE.DirectionalLight(0xffb366,1.35); dir.position.set(-2.5,3.5,1.5);
      dir.castShadow=true; dir.shadow.mapSize.set(2048,2048); dir.shadow.radius=6; scene.add(dir);
      const fire=new THREE.PointLight(0xffa860,0.6,6); fire.position.set(-1.5,1.2,1.2); scene.add(fire);

      listener=new THREE.AudioListener(); camera.add(listener);

      startBtn.addEventListener('click', ()=>{
        overlay.style.display='none'; loading.style.display='grid';
        loadAllAssetsWithProgress(p=>{progressText.textContent=`${p}%`; barFill.style.width=`${p}%`;})
        .then(()=>{ playPortal(); loading.classList.add('fade-out');
          setTimeout(()=>{ loading.remove(); startBGM(); modeBtn.style.display='block'; enableOrbitControls(); },1000);
        });
      }, {once:true});

      modeBtn.addEventListener('click', async ()=>{
        if(activeControls===deviceControls){ enableOrbitControls(); modeBtn.textContent='Управление: ПАЛЕЦ'; toast('Режим: палец (свайп-инверсия)'); }
        else { const ok=await tryEnableDeviceControls();
          if(ok){ modeBtn.textContent='Управление: ТЕЛЕФОН'; toast('Режим: телефоном. Долгий тап — калибровка.'); }
          else { toast('Доступ к датчикам отклонён — остаётся режим пальцем'); }
        }
      });
      modeBtn.addEventListener('contextmenu',e=>{ e.preventDefault(); if(deviceControls&&activeControls===deviceControls){ deviceControls.calibrateToCurrentHeading(); toast('Калибровка выполнена'); }});

      window.addEventListener('resize', ()=>{
        camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
      });

      (function anim(){ requestAnimationFrame(anim);
        fire.intensity=0.55+Math.sin(performance.now()*0.003)*0.15;
        if(activeControls&&activeControls.update) activeControls.update();
        renderer.render(scene,camera);
      })();
    }

    function enableOrbitControls(){
      if(deviceControls&&deviceControls.disconnect){ deviceControls.disconnect(); deviceControls=null; }
      if(!orbitControls){
        orbitControls=new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.target.set(0,1.5,0);
        orbitControls.enableZoom=false; orbitControls.enablePan=false; orbitControls.enableRotate=true;
        orbitControls.minAzimuthAngle=-Infinity; orbitControls.maxAzimuthAngle=Infinity;
        orbitControls.minPolarAngle=THREE.MathUtils.degToRad(2); orbitControls.maxPolarAngle=THREE.MathUtils.degToRad(178);
        orbitControls.enableDamping=true; orbitControls.dampingFactor=0.12; orbitControls.rotateSpeed=-0.8;
        orbitControls.touches={ONE:THREE.TOUCH.ROTATE, TWO:THREE.TOUCH.DOLLY_PAN};
      }
      activeControls=orbitControls;
    }

    async function tryEnableDeviceControls(){
      try{
        if(window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission==='function'){
          const perm=await DeviceOrientationEvent.requestPermission(); if(perm!=='granted') return false;
        }
      }catch(e){ console.warn(e); return false; }
      deviceControls=makeDeviceControls(camera);
      if(orbitControls){ orbitControls.dispose(); orbitControls=null; }
      activeControls=deviceControls; return true;
    }

    // Материалы: sRGB + запасная текстура дерева
    function fixMaterials(root){
      root.traverse(obj=>{
        if(!obj.isMesh) return;
        const apply=mat=>{
          if(!mat) return;
          if(mat.map){ mat.map.colorSpace=THREE.SRGBColorSpace; mat.map.anisotropy=renderer.capabilities.getMaxAnisotropy?.()||8; }
          else if(fallbackWood){ mat.map=fallbackWood; mat.color?.set?.(0xffffff); }
          else { mat.color?.set?.(0x8a5a3a); }
          if(mat.roughness===undefined) mat.roughness=0.85;
          if(mat.metalness===undefined) mat.metalness=0.0;
          if('vertexColors' in mat) mat.vertexColors=false;
          mat.needsUpdate=true;
        };
        if(Array.isArray(obj.material)) obj.material.forEach(apply); else apply(obj.material);
        obj.castShadow=true; obj.receiveShadow=true;
      });
    }

    // Загрузка ассетов (с прогрессом)
    function loadAllAssetsWithProgress(onProgress){
      return new Promise((resolve)=>{
        const manager=new THREE.LoadingManager(
          ()=>resolve(),
          (url,loaded,total)=>{ onProgress?.(Math.min(100, Math.floor(loaded/total*100))); },
          (url)=>console.warn('Ошибка загрузки:', url)
        );

        // Текстуры
        const tl=new THREE.TextureLoader(manager);
        const floorTex=tl.load('assets/textures/floor.jpg'); floorTex.colorSpace=THREE.SRGBColorSpace; floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2);
        const wallTex =tl.load('assets/textures/wall.jpg?v=17'); wallTex.colorSpace=THREE.SRGBColorSpace; wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping;
        const mirrorTex=tl.load('assets/textures/mirror.jpg'); mirrorTex.colorSpace=THREE.SRGBColorSpace;
        fallbackWood  =tl.load('assets/textures/wood.jpg', t=>{t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=renderer.capabilities.getMaxAnisotropy?.()||8;});

        // Комната
        const floor=new THREE.Mesh(new THREE.PlaneGeometry(w,d), new THREE.MeshStandardMaterial({map:floorTex, roughness:0.9}));
        floor.rotation.x=-Math.PI/2; floor.position.y=0.0005; floor.receiveShadow=true; scene.add(floor);

        const wallMat=new THREE.MeshStandardMaterial({map:wallTex, roughness:1.0});
        const walls=[[0,h/2-0.01,-d/2,0],[0,h/2-0.01,d/2,Math.PI],[-w/2,h/2-0.01,0,Math.PI/2],[w/2,h/2-0.01,0,-Math.PI/2]];
        walls.forEach(([x,y,z,ry])=>{ const wall=new THREE.Mesh(new THREE.PlaneGeometry(ry?d:w,h+0.02), wallMat); wall.position.set(x,y,z); if(ry) wall.rotation.y=ry; wall.receiveShadow=true; scene.add(wall); });

        const mirror=new THREE.Mesh(new THREE.PlaneGeometry(0.9,0.6), new THREE.MeshStandardMaterial({map:mirrorTex, metalness:0.85, roughness:0.22}));
        mirror.position.set(0,1.5,-d/2+0.01); scene.add(mirror);

        // Модели
        const gltfLoader=new THREE.GLTFLoader(manager);

        // Сундук
        gltfLoader.load('assets/models/chest.glb',(g)=>{
          const chest=g.scene;
          const b0=new THREE.Box3().setFromObject(chest); chest.position.sub(b0.getCenter(new THREE.Vector3()));
          const target=1.2*CHEST_SIZE_MULT, diag=b0.getSize(new THREE.Vector3()).length(); chest.scale.setScalar(diag>0? target/diag:1);
          const b1=new THREE.Box3().setFromObject(chest); chest.position.y-=b1.min.y;
          chest.position.x=-w/2+CHEST_WALLOFFSET_X; chest.position.z=CHEST_Z; chest.rotation.y=Math.PI;
          fixMaterials(chest); scene.add(chest);
        });

        // Бочки
        const loadBarrels=url=>gltfLoader.load(url,(g)=>{
          const barrels=g.scene;
          const b0=new THREE.Box3().setFromObject(barrels); barrels.position.sub(b0.getCenter(new THREE.Vector3()));
          const H=b0.getSize(new THREE.Vector3()).y||1; barrels.scale.setScalar(BARRELS_TARGET_HEIGHT/H);
          const b1=new THREE.Box3().setFromObject(barrels); barrels.position.y-=b1.min.y;
          barrels.position.x=-w/2+BARRELS_WALLOFFSET_X; barrels.position.z=BARRELS_Z; if(BARRELS_ROT_LEFT_90) barrels.rotation.y=Math.PI/2;
          fixMaterials(barrels); scene.add(barrels);
        },undefined,(e)=>console.warn('Ошибка',url,e));
        loadBarrels('assets/models/barrel_light.glb');
        loadBarrels('assets/models/barrel.glb');

        // БАЛКИ — plank.glb
        gltfLoader.load('assets/models/plank.glb',(g)=>{
          const root=g.scene;

          function prepareUnit(src){
            const box=new THREE.Box3().setFromObject(src);
            src.position.sub(box.getCenter(new THREE.Vector3()));
            const s=box.getSize(new THREE.Vector3());
            let axis='y'; if(s.x>=s.y && s.x>=s.z) axis='x'; else if(s.z>=s.y && s.z>=s.x) axis='z';
            if(axis==='x') src.rotation.set(0,0,Math.PI/2); else if(axis==='z') src.rotation.set(-Math.PI/2,0,0);

            const box2=new THREE.Box3().setFromObject(src), lenY=Math.max(box2.getSize(new THREE.Vector3()).y,1e-6);
            src.scale.multiplyScalar(1/lenY);

            const base=new THREE.Box3().setFromObject(src).getSize(new THREE.Vector3());
            const baseX=Math.max(base.x,1e-6), baseZ=Math.max(base.z,1e-6);

            const unit=new THREE.Group(); unit.add(src);

            function spawnBetween(a,b,th=BEAM_THICKNESS){
              const clone=unit.clone(true);
              const dir=new THREE.Vector3().subVectors(b,a), len=dir.length(); if(len<1e-6) return null;
              const mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);

              clone.scale.set(th/baseX, len + BEAM_MITER_OVERLAP*2, th/baseZ);
              const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
              clone.quaternion.copy(q);
              clone.position.copy(mid);

              clone.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; } });
              fixMaterials(clone); scene.add(clone); return clone;
            }
            return {spawnBetween};
          }

          const {spawnBetween}=prepareUnit(root);

          // Центры сечений — на полтолщины от стен/потолка
          const half = BEAM_THICKNESS * 0.5;
          const xL = -w/2 + BEAM_INSET_WALL + half;
          const xR =  w/2 - BEAM_INSET_WALL - half;
          const zB = -d/2 + BEAM_INSET_WALL + half; // задняя
          const zF =  d/2 - BEAM_INSET_WALL - half; // передняя

          const y0 = 0 + POST_FLOOR_GAP + half;           // низ стоек (центр)
          const yT = h - BEAM_INSET_CEIL - half;          // верх стоек (центр → верхняя плоскость ровно у потолка)
          const yH = yT - half;                           // центр горизонтальных, чтобы верх совпал с потолком и со стойками

          // 4 вертикальные стойки
          spawnBetween(new THREE.Vector3(xL,y0,zB), new THREE.Vector3(xL,yT,zB));
          spawnBetween(new THREE.Vector3(xR,y0,zB), new THREE.Vector3(xR,yT,zB));
          spawnBetween(new THREE.Vector3(xL,y0,zF), new THREE.Vector3(xL,yT,zF));
          spawnBetween(new THREE.Vector3(xR,y0,zF), new THREE.Vector3(xR,yT,zF));

          // 4 горизонтальные под потолком (с заходом в углы)
          spawnBetween(new THREE.Vector3(xL-BEAM_MITER_OVERLAP,yH,zB), new THREE.Vector3(xR+BEAM_MITER_OVERLAP,yH,zB)); // задняя
          spawnBetween(new THREE.Vector3(xL-BEAM_MITER_OVERLAP,yH,zF), new THREE.Vector3(xR+BEAM_MITER_OVERLAP,yH,zF)); // передняя
          spawnBetween(new THREE.Vector3(xL,yH,zB-BEAM_MITER_OVERLAP), new THREE.Vector3(xL,yH,zF+BEAM_MITER_OVERLAP)); // левая
          spawnBetween(new THREE.Vector3(xR,yH,zB-BEAM_MITER_OVERLAP), new THREE.Vector3(xR,yH,zF+BEAM_MITER_OVERLAP)); // правая
        },undefined,(e)=>console.warn('Ошибка plank.glb',e));

        // страховка от вечной загрузки
        setTimeout(()=>resolve(),12000);
      });
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
