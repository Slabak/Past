<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Комната — бочка слева от стола + щит</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:5;
    background:radial-gradient(ellipse at center,rgba(0,0,0,.78),rgba(0,0,0,.95));
    color:#fff;font:16px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #overlay button{padding:12px 18px;border:none;border-radius:10px;background:#ffb366;color:#000;cursor:pointer}
  .vr-btn{position:fixed;left:12px;bottom:12px;z-index:7;background:#1e1e1e;color:#fff;border:1px solid #444;border-radius:8px;padding:10px 14px;font:14px system-ui;cursor:pointer}
  .vr-btn[disabled]{opacity:.4;cursor:not-allowed}
</style>
</head>
<body>
  <div id="overlay">
    <div style="text-align:center">
      <div style="margin-bottom:12px;font-size:18px">Переносимся через портал…</div>
      <button id="enter">Войти</button>
      <div style="margin-top:10px;font-size:12px;opacity:.7">Экран и VR (Quest) поддерживаются</div>
    </div>
  </div>

  <!-- three.js -->
  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>
<script>
/* ===== простая VR-кнопка без внешних файлов ===== */
function createSimpleVRButton(renderer){
  const btn=document.createElement('button'); btn.className='vr-btn'; btn.textContent='Войти в VR';
  if(!('xr' in navigator)){ btn.textContent='VR не поддерживается'; btn.disabled=true; return btn; }
  let session=null;
  async function onEnd(){ session.removeEventListener('end', onEnd); session=null; btn.textContent='Войти в VR'; }
  async function onStart(s){ session=s; s.addEventListener('end', onEnd); await renderer.xr.setSession(s); btn.textContent='Выйти из VR'; }
  btn.addEventListener('click', async ()=>{
    try{
      if(!session){
        const s=await navigator.xr.requestSession('immersive-vr',{requiredFeatures:['local-floor']});
        onStart(s);
      } else { await session.end(); }
    }catch(e){ console.warn('XR error',e); }
  });
  return btn;
}

/* ===== размеры комнаты ===== */
const W=4, D=4, H=3;

/* ===== ресурсы ===== */
const TEX_FLOOR='assets/textures/floor.jpg';
const TEX_WALL ='assets/textures/wall.jpg';
const TEX_CEIL ='assets/textures/potolok.jpg';

const MODEL_TABLE ='assets/models/table.glb';
const MODEL_BARREL='assets/models/barrel.glb';
const MODEL_CHEST ='assets/models/chest.glb';
const MODEL_GLOBUS='assets/models/globus.glb';
const MODEL_DOOR  ='assets/models/door.glb';
const MODEL_SHIELD='assets/models/shield.glb';

/* ===== позиции (метры) ===== */
// стол — задняя стена под «зеркалом»
const POS_TABLE  = new THREE.Vector3( 0.0, 0.0, -D/2 + 0.55);
// сундук — левая стена, ближе к зрителю
const POS_CHEST_X = -W/2 + 0.45;
const POS_CHEST_Z =  1.10;
// БОЧКА — СЛЕВА ОТ СТОЛА (задний левый угол)
const POS_BARREL = new THREE.Vector3( -W/2 + 0.55, 0.0, -D/2 + 0.65 );
const BARREL_HEIGHT = 1.0; // м
// глобус — правая стена ближе к задней
const POS_GLOBUS  = new THREE.Vector3( W/2 - 0.55, 0.0, -D/2 + 0.90 );
// дверь — в плоскости передней стены, утоп на 5 мм
const POS_DOOR    = new THREE.Vector3( 0.0, 0.0,  D/2 - 0.005 );
// ЩИТ — правая стена, повыше, немного ближе к центру стены (чуть «правее» от глобуса)
const POS_SHIELD  = new THREE.Vector3( W/2 - 0.02, 1.55, -0.40 );
const SHIELD_HEIGHT = 0.80;

/* ===== глобальные ===== */
let scene,camera,renderer,controls,tl;

function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x0b0706);
  scene.fog=new THREE.Fog(0x120b08,6,14);

  camera=new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 100);
  camera.position.set(0,1.6,2.8);

  renderer=new THREE.WebGLRenderer({antialias:true});
  const isMobile=/Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);
  renderer.setPixelRatio(isMobile? 1 : Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputColorSpace=THREE.SRGBColorSpace;
  renderer.toneMapping=THREE.ACESFilmicToneMapping; renderer.toneMappingExposure=1.05;
  renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap;

  renderer.xr.enabled=true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(createSimpleVRButton(renderer));

  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.target.set(0,1.2,0);
  controls.enableDamping=true; controls.enablePan=false; controls.enableZoom=false;
  controls.rotateSpeed=-0.8; controls.dampingFactor=0.12;

  tl=new THREE.TextureLoader();

  buildRoom();     // стены/пол/потолок + свет
  loadModels();    // мебель + щит

  addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);
  });

  renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene,camera); });

  document.getElementById('enter').addEventListener('click',()=>{
    document.getElementById('overlay').style.display='none';
  },{once:true});
}

/* ===== комната ===== */
function buildRoom(){
  const floorTex=tl.load(TEX_FLOOR); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2); floorTex.colorSpace=THREE.SRGBColorSpace;
  const wallTex =tl.load(TEX_WALL ); wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping; wallTex.colorSpace=THREE.SRGBColorSpace;
  const ceilTex =tl.load(TEX_CEIL ); ceilTex.wrapS=ceilTex.wrapT=THREE.RepeatWrapping; ceilTex.repeat.set(2,2); ceilTex.colorSpace=THREE.SRGBColorSpace;

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:floorTex,roughness:.9}));
  floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

  const wallMat=new THREE.MeshStandardMaterial({map:wallTex,roughness:1});
  const back =new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); back.position.set(0,H/2,-D/2); scene.add(back);
  const front=new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); front.position.set(0,H/2, D/2); front.rotation.y=Math.PI; scene.add(front);
  const left =new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); left.position.set(-W/2,H/2,0); left.rotation.y= Math.PI/2; scene.add(left);
  const right=new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); right.position.set( W/2,H/2,0); right.rotation.y=-Math.PI/2; scene.add(right);

  const ceil=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:ceilTex,roughness:.85}));
  ceil.position.set(0,H,0); ceil.rotation.x=Math.PI/2; scene.add(ceil);

  // мягкий тёплый свет
  scene.add(new THREE.HemisphereLight(0xffdcb8,0x1b0e0a,0.38));
  scene.add(new THREE.AmbientLight(0xffe0bb,0.2));
  const dir=new THREE.DirectionalLight(0xffb06a,1.05);
  dir.position.set(-2.5,3.2,1.5); dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); dir.shadow.radius=4; scene.add(dir);
  const fire=new THREE.PointLight(0xffa860,0.58,5.0); fire.position.set(-1.4,1.15,1.1); scene.add(fire);
}

/* ===== утилита подгонки по высоте ===== */
function fitByHeight(root, targetH){
  root.traverse(o=>{ if(o.isMesh){o.castShadow=o.receiveShadow=true; }});
  const b=new THREE.Box3().setFromObject(root);
  const h=b.getSize(new THREE.Vector3()).y||1;
  const k=targetH/h;
  root.scale.setScalar(k);
  const b2=new THREE.Box3().setFromObject(root);
  root.position.sub(b2.getCenter(new THREE.Vector3()));
  const b3=new THREE.Box3().setFromObject(root);
  root.position.y -= b3.min.y; // на пол
}

/* ===== загрузка моделей ===== */
function loadModels(){
  const L=new THREE.GLTFLoader();

  // стол ~ 0.78 м
  L.load(MODEL_TABLE,(g)=>{
    const m=g.scene; fitByHeight(m, 0.78);
    m.position.copy(POS_TABLE);
    scene.add(m);
  });

  // сундук
  L.load(MODEL_CHEST,(g)=>{
    const chest=g.scene;
    chest.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; } });
    const box0=new THREE.Box3().setFromObject(chest);
    chest.position.sub(box0.getCenter(new THREE.Vector3()));
    const targetDiag=1.2*1.5; // как раньше
    const diag0=box0.getSize(new THREE.Vector3()).length();
    const s=diag0>0 ? targetDiag/diag0 : 1;
    chest.scale.setScalar(s);
    const box1=new THREE.Box3().setFromObject(chest);
    chest.position.y -= box1.min.y;
    chest.position.set(POS_CHEST_X, 0, POS_CHEST_Z);
    chest.rotation.y = Math.PI;
    scene.add(chest);
  });

  // БОЧКА — СЛЕВА ОТ СТОЛА
  L.load(MODEL_BARREL,(g)=>{
    const m=g.scene; fitByHeight(m, BARREL_HEIGHT);
    m.position.copy(POS_BARREL);
    m.rotation.y=0; // вдоль задней стены
    scene.add(m);
  });

  // глобус ~ 1.2 м — правая стена
  L.load(MODEL_GLOBUS,(g)=>{
    const m=g.scene; fitByHeight(m, 1.20);
    m.position.copy(POS_GLOBUS);
    m.rotation.y=-Math.PI/2;
    scene.add(m);
  });

  // дверь ~ 2.1 м — плоскость передней стены
  L.load(MODEL_DOOR,(g)=>{
    const m=g.scene; fitByHeight(m, 2.10);
    // минимальная толщина к стене
    const rotations=[0, Math.PI/2, Math.PI, -Math.PI/2];
    let bestR = 0, bestZ = Infinity;
    rotations.forEach(r=>{
      m.rotation.set(0,r,0);
      const bb=new THREE.Box3().setFromObject(m);
      const size=bb.getSize(new THREE.Vector3());
      if(size.z < bestZ){ bestZ=size.z; bestR=r; }
    });
    m.rotation.set(0,bestR,0);
    m.position.copy(POS_DOOR);
    scene.add(m);
  });

  // ЩИТ — на правую стену, повыше, чуть к центру
  L.load(MODEL_SHIELD,(g)=>{
    const shield=g.scene;
    // подгоняем по высоте (щит плоский, но модель может быть с разными осями)
    shield.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; }});
    // нормируем размер по высоте
    (function fitShieldByHeight(root, targetH){
      const b=new THREE.Box3().setFromObject(root);
      const h=b.getSize(new THREE.Vector3()).y||1;
      const k=targetH/h;
      root.scale.setScalar(k);
      const b2=new THREE.Box3().setFromObject(root);
      root.position.sub(b2.getCenter(new THREE.Vector3()));
    })(shield, SHIELD_HEIGHT);

    // положить на правую стену и чуть утопить
    shield.position.set(POS_SHIELD.x, POS_SHIELD.y, POS_SHIELD.z);
    // развернуть лицом в комнату
    shield.rotation.y = -Math.PI/2;
    // лёгкий вынос из стены, чтобы не мигал
    shield.position.x = W/2 - 0.01;

    scene.add(shield);
  });
}

window.addEventListener('load', init);
</script>
</body>
</html>
