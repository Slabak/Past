<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Комната — дверь утоплена</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:5;
    background:radial-gradient(ellipse at center,rgba(0,0,0,.78),rgba(0,0,0,.95));
    color:#fff;font:16px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #overlay button{padding:12px 18px;border:none;border-radius:10px;background:#ffb366;color:#000;cursor:pointer}
  .vr-btn{position:fixed;left:12px;bottom:12px;z-index:7;background:#1e1e1e;color:#fff;border:1px solid #444;border-radius:8px;padding:10px 14px;font:14px system-ui;cursor:pointer}
  .vr-btn[disabled]{opacity:.4;cursor:not-allowed}
</style>
</head>
<body>
  <div id="overlay">
    <div style="text-align:center">
      <div style="margin-bottom:12px;font-size:18px">Переносимся через портал…</div>
      <button id="enter">Войти</button>
    </div>
  </div>

  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>

<script>
/* --- мини VR-кнопка --- */
function createSimpleVRButton(renderer){
  const btn=document.createElement('button'); btn.className='vr-btn'; btn.textContent='Войти в VR';
  if(!('xr' in navigator)){ btn.textContent='VR не поддерживается'; btn.disabled=true; return btn; }
  let session=null;
  async function onEnd(){ session.removeEventListener('end', onEnd); session=null; btn.textContent='Войти в VR'; }
  btn.addEventListener('click', async ()=>{
    try{
      if(!session){
        const s=await navigator.xr.requestSession('immersive-vr',{requiredFeatures:['local-floor']});
        session=s; s.addEventListener('end', onEnd); await renderer.xr.setSession(s); btn.textContent='Выйти из VR';
      }else{ await session.end(); }
    }catch(e){ console.warn('XR error',e); }
  });
  return btn;
}

/* --- размеры комнаты --- */
const W=4, D=4, H=3;

/* --- пути --- */
const TEX_FLOOR='assets/textures/floor.jpg';
const TEX_WALL ='assets/textures/wall.jpg';
const TEX_CEIL ='assets/textures/potolok.jpg';
const MODEL_TABLE ='assets/models/table.glb';
const MODEL_BARREL='assets/models/barrel.glb';
const MODEL_CHEST ='assets/models/chest.glb';
const MODEL_GLOBUS='assets/models/globus.glb';
const MODEL_DOOR  ='assets/models/door.glb';
const MODEL_SHIELD='assets/models/shield.glb';

/* --- позиции объектов --- */
const POS_TABLE   = new THREE.Vector3( 0.0, 0.0, -D/2 + 0.55);
const POS_CHEST_X = -W/2 + 0.45;
const POS_CHEST_Z =  1.10;
const POS_BARREL  = new THREE.Vector3( -W/2 + 0.55, 0.0, -D/2 + 0.65 );
const POS_GLOBUS  = new THREE.Vector3(  W/2 - 0.55, 0.0, -D/2 + 0.90 );
const POS_SHIELD  = new THREE.Vector3(  W/2 - 0.07, 1.55, -0.40 );
const SHIELD_HEIGHT = 0.80;

let scene,camera,renderer,controls,tl;

function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x0b0706);
  scene.fog=new THREE.Fog(0x120b08,6,14);

  camera=new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 100);
  camera.position.set(0,1.6,2.8);

  renderer=new THREE.WebGLRenderer({antialias:true});
  const isMobile=/Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);
  renderer.setPixelRatio(isMobile?1:Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputColorSpace=THREE.SRGBColorSpace;
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=1.05;
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.PCFSoftShadowMap;
  renderer.xr.enabled=true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(createSimpleVRButton(renderer));

  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.target.set(0,1.2,0);
  controls.enableDamping=true; controls.enablePan=false; controls.enableZoom=false;
  controls.rotateSpeed=-0.8; controls.dampingFactor=0.12;

  tl=new THREE.TextureLoader();

  buildRoom();
  loadModels();

  addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });

  renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene,camera); });

  document.getElementById('enter').addEventListener('click',()=>{
    document.getElementById('overlay').style.display='none';
  },{once:true});
}

function buildRoom(){
  const floorTex=tl.load(TEX_FLOOR); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2); floorTex.colorSpace=THREE.SRGBColorSpace;
  const wallTex =tl.load(TEX_WALL ); wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping; wallTex.colorSpace=THREE.SRGBColorSpace;
  const ceilTex =tl.load(TEX_CEIL ); ceilTex.wrapS=ceilTex.wrapT=THREE.RepeatWrapping; ceilTex.repeat.set(2,2); ceilTex.colorSpace=THREE.SRGBColorSpace;

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:floorTex,roughness:.9}));
  floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

  const wallMat=new THREE.MeshStandardMaterial({map:wallTex,roughness:1});
  const back =new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); back.position.set(0,H/2,-D/2); scene.add(back);
  const front=new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); front.position.set(0,H/2, D/2); front.rotation.y=Math.PI; scene.add(front);
  const left =new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); left.position.set(-W/2,H/2,0); left.rotation.y= Math.PI/2; scene.add(left);
  const right=new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); right.position.set( W/2,H/2,0); right.rotation.y=-Math.PI/2; scene.add(right);

  const ceil=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:ceilTex,roughness:.85}));
  ceil.position.set(0,H,0); ceil.rotation.x=Math.PI/2; scene.add(ceil);

  scene.add(new THREE.HemisphereLight(0xffdcb8,0x1b0e0a,0.38));
  scene.add(new THREE.AmbientLight(0xffe0bb,0.2));
  const dir=new THREE.DirectionalLight(0xffb06a,1.05);
  dir.position.set(-2.5,3.2,1.5); dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); dir.shadow.radius=4; scene.add(dir);
  const fire=new THREE.PointLight(0xffa860,0.58,5.0); fire.position.set(-1.4,1.15,1.1); scene.add(fire);
}

/* подгон по высоте + на пол */
function fitByHeight(root, targetH){
  root.traverse(o=>{ if(o.isMesh){o.castShadow=o.receiveShadow=true; }});
  const b=new THREE.Box3().setFromObject(root);
  const h=b.getSize(new THREE.Vector3()).y||1;
  const k=targetH/h;
  root.scale.setScalar(k);
  const b2=new THREE.Box3().setFromObject(root);
  root.position.sub(b2.getCenter(new THREE.Vector3()));
  const b3=new THREE.Box3().setFromObject(root);
  root.position.y -= b3.min.y;
}

/* аккуратное «утопление» во фронтальную стену */
function snapToFrontWall(mesh, inset=-0.018){ // inset < 0 — утопить немного внутрь
  const box=new THREE.Box3().setFromObject(mesh);
  const maxZ=box.max.z;            // край, который ближе всего к зрителю
  const target=D/2 + inset;        // плоскость стены с небольшим отрицательным отступом
  const dz=target - maxZ;          // сколько сдвинуть весь объект
  mesh.position.z += dz;
}

function loadModels(){
  const L=new THREE.GLTFLoader();

  L.load(MODEL_TABLE,(g)=>{ const m=g.scene; fitByHeight(m,0.78); m.position.copy(POS_TABLE); scene.add(m); });

  L.load(MODEL_CHEST,(g)=>{ const m=g.scene; fitByHeight(m,0.95); m.position.set(POS_CHEST_X,0,POS_CHEST_Z); m.rotation.y=Math.PI; scene.add(m); });

  L.load(MODEL_BARREL,(g)=>{ const m=g.scene; fitByHeight(m,1.15); m.position.copy(POS_BARREL); scene.add(m); });

  L.load(MODEL_GLOBUS,(g)=>{ const m=g.scene; fitByHeight(m,1.2); m.position.copy(POS_GLOBUS); m.rotation.y=-Math.PI/2; scene.add(m); });

  /* ДВЕРЬ: поворот на 90° и точная подгонка к стене без щели */
  L.load(MODEL_DOOR,(g)=>{
    const m=g.scene;
    fitByHeight(m,2.1);
    m.rotation.set(0, Math.PI/2, 0);        // 90° вокруг Y
    // черновая постановка — примерно к передней стене
    const b0=new THREE.Box3().setFromObject(m);
    const depth=b0.getSize(new THREE.Vector3()).z;
    m.position.set(0,0, D/2 - depth*0.5);
    // точная подгонка по bbox: утопить на 18 мм внутрь
    snapToFrontWall(m, -0.018);
    scene.add(m);
  });

  L.load(MODEL_SHIELD,(g)=>{
    const m=g.scene; fitByHeight(m,SHIELD_HEIGHT);
    m.rotation.y=-Math.PI/2; m.position.copy(POS_SHIELD); scene.add(m);
  });
}

window.addEventListener('load',init);
</script>
</body>
</html>
