<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Комната прошлого — разлом</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  #overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:10;background:radial-gradient(ellipse at center,rgba(0,0,0,.82),rgba(0,0,0,.96));color:#fff}
  .panel{display:flex;flex-direction:column;gap:14px;align-items:center;padding:22px 26px;border-radius:14px;background:rgba(20,10,6,.55);backdrop-filter:blur(3px);box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .title{font-size:18px;opacity:.92}
  .btn{cursor:pointer;border:0;border-radius:10px;padding:12px 16px;background:#6b3c1e;color:#fff;font-weight:600}
  .btn.secondary{background:#3a2a22}
  .note{font-size:12px;opacity:.75}
  #loading{position:fixed;inset:0;display:none;place-items:center;z-index:12;background:radial-gradient(ellipse at center,rgba(0,0,0,.88),rgba(0,0,0,.98));color:#fff}
  .loadbox{display:flex;flex-direction:column;align-items:center;gap:12px}
  .ring{width:110px;height:110px;border-radius:50%;background:conic-gradient(#ffb366 var(--p,0%), rgba(255,255,255,.08) 0);-webkit-mask:radial-gradient(circle at center, transparent 58%, #000 60%);mask:radial-gradient(circle at center, transparent 58%, #000 60%);box-shadow:0 0 0 1px rgba(255,255,255,.1) inset}
  .percent{font:18px/1.1 monospace}
  .hint{font:14px;opacity:.85;animation:pulse 1.6s ease-in-out infinite}
  @keyframes pulse{0%{opacity:.55}50%{opacity:1}100%{opacity:.55}}
  #black{position:fixed;inset:0;background:#000;pointer-events:none;z-index:11;opacity:0;transition:opacity .5s ease}
  #black.on{opacity:1}
  #black .msg{position:absolute;left:0;right:0;bottom:20%;text-align:center;color:#fff;font-size:16px;opacity:.9}
  canvas.fade-in{animation:fi .5s ease forwards}@keyframes fi{from{opacity:0}to{opacity:1}}

  /* VR HUD */
  #hud{position:fixed;right:10px;bottom:10px;z-index:20;background:rgba(0,0,0,.55);color:#fff;font:12px/1.35 monospace;border:1px solid rgba(255,255,255,.2);border-radius:8px;padding:8px 10px;display:none;max-width:60vw}
  #hud.show{display:block}
  #hud .hdr{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;opacity:.9}
  #hud button{font:12px monospace;border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,.07);color:#fff;border-radius:6px;cursor:pointer;padding:2px 6px}
</style>
</head>
<body>
  <div id="overlay">
    <div class="panel">
      <div class="title">портал открыт. как войдём?</div>
      <button id="btnVR" class="btn">Войти в разлом (VR)</button>
      <button id="btnFlat" class="btn secondary">Оглядеться со стороны</button>
      <div class="note">переход займёт несколько секунд</div>
    </div>
  </div>

  <div id="loading">
    <div class="loadbox">
      <div class="ring" id="ring"></div>
      <div class="percent" id="percent">0%</div>
      <div class="hint">переносим материю…</div>
    </div>
  </div>

  <div id="black"><div class="msg">переносим материю…</div></div>

  <!-- VR HUD -->
  <div id="hud">
    <div class="hdr">VR-HUD <button id="hudToggle">hide</button></div>
    <div id="hudLog">…</div>
  </div>

  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>

<script>
/* ---------- пути/константы ---------- */
const W=4,D=4,H=3;
const TEX_FLOOR='assets/textures/floor.jpg';
const TEX_WALL ='assets/textures/wall.jpg?v=9';
const TEX_CEIL ='assets/textures/potolok.jpg?v=3';
const TEX_MIRROR='assets/textures/mirror.jpg';

const MODEL_CHEST ='assets/models/chest.glb?v=2';
const MODEL_BARREL='assets/models/barrel.glb';
const MODEL_TABLE ='assets/models/table.glb';
const MODEL_GLOBUS='assets/models/globus.glb';
const MODEL_DOOR  ='assets/models/door.glb';
const MODEL_SHIELD='assets/models/shield.glb';
const MODEL_BENCH ='assets/models/bench.glb?v=1';
const MODEL_LANTERN='assets/models/lantern.glb'; // опционально

const MUSIC='assets/music/music.mp3';

/* проверенные позы */
const POS_CHEST_X=-W/2+0.45, POS_CHEST_Z=1.10;
const POS_BARREL=new THREE.Vector3(-W/2+0.55,0,-D/2+0.65);
const POS_TABLE =new THREE.Vector3(0,0,-D/2+0.55);
const POS_GLOBUS=new THREE.Vector3(W/2-0.55,0,-D/2+0.90);
const POS_SHIELD=new THREE.Vector3(W/2-0.07,1.55,-0.40);
const POS_BENCH =new THREE.Vector3(POS_TABLE.x+0.05,0,POS_TABLE.z+0.62);
const ROT_BENCH_Y=0.22;

/* UI refs */
const overlay=document.getElementById('overlay');
const loading=document.getElementById('loading');
const ring=document.getElementById('ring');
const percent=document.getElementById('percent');
const black=document.getElementById('black');

const hud=document.getElementById('hud');
const hudLog=document.getElementById('hudLog');
document.getElementById('hudToggle').onclick=()=>hud.classList.toggle('show');

/* helpers */
const setProgress=(p)=>{ring.style.setProperty('--p',p+'%');percent.textContent=Math.round(p)+'%';};
const showLoading=(p=0)=>{loading.style.display='grid';setProgress(p);};
const hideLoading=()=>{loading.style.display='none';};
const fadeBlack=(on)=>black.classList.toggle('on',!!on);
const log=(...a)=>{ hudLog.textContent = (hudLog.textContent+'\n'+a.join(' ')).trim().slice(-1400); };

/* three globals */
let scene,camera,renderer,controls,tl,manager;
let amb,hemi,sun,fl1,fl2;
let listener,music;
let holdTimer=null,holding=false;
let vrPlanned=false, fullyLoaded=false;

/* фонарь */
let lanternLights=[], lanternNodes=[];
const LANTERN_INT=3.0, LANTERN_DIST=8.0;
const LANTERN_SIZE_M=0.28;

/* старт */
document.getElementById('btnVR').addEventListener('click',startVR,{once:true});
document.getElementById('btnFlat').addEventListener('click',startFlat,{once:true});
window.addEventListener('keydown',e=>{ if(e.key.toLowerCase()==='h') hud.classList.toggle('show'); });

async function startVR(){
  overlay.style.display='none';
  showLoading(0); fadeBlack(true); vrPlanned=true;
  initRenderer();

  let canVR=false;
  try{ canVR = !!navigator.xr && await navigator.xr.isSessionSupported('immersive-vr'); }catch(_){}
  if(!canVR){ log('no XR support → flat'); await boot(false); fadeBlack(false); return; }

  try{
    const session=await navigator.xr.requestSession('immersive-vr',{requiredFeatures:['local-floor']});
    await renderer.xr.setSession(session);
  }catch(e){ log('requestSession error'); await boot(false); fadeBlack(false); return; }

  await boot(true);
  // ждём полной загрузки и sessionstart → снимаем завесу чуть позже
  const safeDrop = ()=>{ if(fullyLoaded){ setTimeout(()=>fadeBlack(false),500); } else { setTimeout(safeDrop,100); } };
  safeDrop();
}

async function startFlat(){
  overlay.style.display='none'; showLoading(0); vrPlanned=false;
  initRenderer(); await boot(false);
}

async function boot(isVR){
  manager=new THREE.LoadingManager();
  manager.onProgress=(_,l,t)=>setProgress(t?l/t*100:0);
  manager.onLoad=()=>{ setProgress(100); fullyLoaded=true; log('assets loaded'); };

  initScene(isVR);
  buildRoom();
  await loadModels();

  startMusic();
  hideLoading();
}

/* ---------- renderer/scene ---------- */
function initRenderer(){
  if(renderer) return;
  renderer=new THREE.WebGLRenderer({antialias:true});
  const isMobile=/Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);
  renderer.setPixelRatio(isMobile?1:Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputColorSpace=THREE.SRGBColorSpace;
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=0.92;
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.PCFSoftShadowMap;
  renderer.xr.enabled=true;
  document.body.appendChild(renderer.domElement);
  renderer.domElement.classList.add('fade-in');

  addEventListener('resize',()=>{
    if(!camera) return;
    camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });

  renderer.setAnimationLoop(()=>{ animate(); });
}

function initScene(isVR){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x090605);
  scene.fog=new THREE.Fog(0x140b08,5.5,13);

  camera=new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 100);
  camera.position.set(0,1.6,2.8);

  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.target.set(0,1.2,0);
  controls.enableDamping=true; controls.enablePan=false; controls.enableZoom=false;
  controls.rotateSpeed=-0.8; controls.dampingFactor=0.12;

  tl=new THREE.TextureLoader(manager);

  const k = isVR ? 0.22 : 1.0; // VR очень темно
  amb = new THREE.AmbientLight(0xffe0bd,0.22*k);
  hemi= new THREE.HemisphereLight(0xffd4a8,0x120806,0.24*k);
  sun = new THREE.DirectionalLight(0xffa864,0.65*k);
  sun.position.set(-2.4,3.1,1.2);
  sun.castShadow=true; sun.shadow.mapSize.set(1024,1024); sun.shadow.radius=5; sun.shadow.bias=-0.00015;
  scene.add(amb,hemi,sun);

  fl1=new THREE.PointLight(0xffa860,0.30*k,5.5); fl1.position.set(-1.2,1.15,1.15);
  fl2=new THREE.PointLight(0xff9a58,0.24*k,4.8);  fl2.position.set(0.25,1.05,-1.55);
  scene.add(fl1,fl2);

  renderer.xr.addEventListener('sessionstart',onXRStart);
  renderer.xr.addEventListener('sessionend',onXREnd);
}

function animate(){
  if(controls && controls.update) controls.update();
  const t=performance.now()*0.0025;
  if(fl1) fl1.intensity = 0.30 + Math.sin(t*3.2)*0.06 + Math.sin(t*5.3)*0.04;
  if(fl2) fl2.intensity = 0.24 + Math.sin(t*3.7)*0.05 + Math.sin(t*4.7)*0.03;

  // страховка: если VR включен и фонарей нет — слабая аварийная подсветка от головы
  if(vrPlanned && renderer.xr.isPresenting && lanternLights.length===0){
    const headLight = scene.getObjectByName('__head_fallback');
    if(!headLight){
      const l=new THREE.PointLight(0xffd0a0,0.18,2.5); l.name='__head_fallback';
      scene.add(l);
    }
    const camPos=new THREE.Vector3(); camera.getWorldPosition(camPos);
    scene.getObjectByName('__head_fallback').position.copy(camPos);
  }else{
    const hl=scene.getObjectByName('__head_fallback'); if(hl) hl.parent.remove(hl);
  }

  renderer.render(scene,camera);
}

/* ---------- комната ---------- */
function buildRoom(){
  const tl = new THREE.TextureLoader(manager);
  const floorTex=tl.load(TEX_FLOOR); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2); floorTex.colorSpace=THREE.SRGBColorSpace;
  const wallTex =tl.load(TEX_WALL ); wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping; wallTex.colorSpace=THREE.SRGBColorSpace;
  const ceilTex =tl.load(TEX_CEIL ); ceilTex.wrapS=ceilTex.wrapT=THREE.RepeatWrapping; ceilTex.repeat.set(2,2); ceilTex.colorSpace=THREE.SRGBColorSpace;
  const mirrorTex=tl.load(TEX_MIRROR); mirrorTex.colorSpace=THREE.SRGBColorSpace;

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:floorTex,roughness:.92}));
  floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor); freeze(floor);

  const wallMat=new THREE.MeshStandardMaterial({map:wallTex,roughness:1});
  const back =new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); back.position.set(0,H/2,-D/2);
  const front=new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); front.position.set(0,H/2, D/2); front.rotation.y=Math.PI;
  const left =new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); left.position.set(-W/2,H/2,0); left.rotation.y= Math.PI/2;
  const right=new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); right.position.set( W/2,H/2,0); right.rotation.y=-Math.PI/2;
  [back,front,left,right].forEach(w=>{w.receiveShadow=true; scene.add(w); freeze(w);});

  const ceil=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:ceilTex,roughness:.88}));
  ceil.position.set(0,H,0); ceil.rotation.x=Math.PI/2; scene.add(ceil); freeze(ceil);

  const mirror=new THREE.Mesh(new THREE.PlaneGeometry(.9,.6), new THREE.MeshStandardMaterial({map:mirrorTex,metalness:.8,roughness:.25}));
  mirror.position.set(0,1.5,-D/2+0.01); scene.add(mirror); freeze(mirror);
}

/* ---------- утилиты ---------- */
function fitByHeight(root,targetH){
  root.traverse(o=>{ if(o.isMesh){o.castShadow=o.receiveShadow=true;} });
  const b=new THREE.Box3().setFromObject(root);
  const h=b.getSize(new THREE.Vector3()).y||1;
  const k=targetH/h; root.scale.setScalar(k);
  const b2=new THREE.Box3().setFromObject(root);
  root.position.sub(b2.getCenter(new THREE.Vector3()));
  const b3=new THREE.Box3().setFromObject(root);
  root.position.y -= b3.min.y;
}
function freeze(obj){ obj.updateMatrix(); obj.matrixAutoUpdate=false; obj.traverse?.(o=>{if(o.isMesh){o.updateMatrix();o.matrixAutoUpdate=false;}}); }
function snapToFrontWall(mesh,inset=-0.018){
  const box=new THREE.Box3().setFromObject(mesh);
  const maxZ=box.max.z, target=D/2+inset;
  mesh.position.z += (target-maxZ);
}

/* ---------- модели ---------- */
async function loadModels(){
  const L=new THREE.GLTFLoader(manager);

  await new Promise(res=>L.load(MODEL_CHEST,(g)=>{
    const m=g.scene; fitByHeight(m,0.95);
    m.position.set(POS_CHEST_X,0,POS_CHEST_Z); m.rotation.y=0;
    scene.add(m); freeze(m); res();
  }));

  await new Promise(res=>L.load(MODEL_BARREL,(g)=>{
    const m=g.scene; fitByHeight(m,1.15);
    m.position.copy(POS_BARREL); scene.add(m); freeze(m); res();
  }));

  await new Promise(res=>L.load(MODEL_TABLE,(g)=>{
    const m=g.scene; fitByHeight(m,0.78);
    m.position.copy(POS_TABLE); scene.add(m); freeze(m); res();
  }));

  await new Promise(res=>L.load(MODEL_BENCH,(g)=>{
    const m=g.scene; fitByHeight(m,0.48);
    m.position.copy(POS_BENCH); m.rotation.y=ROT_BENCH_Y;
    m.position.z=Math.min(m.position.z,-D/2+1.05);
    scene.add(m); freeze(m); res();
  }));

  await new Promise(res=>L.load(MODEL_GLOBUS,(g)=>{
    const m=g.scene; fitByHeight(m,1.2);
    m.position.copy(POS_GLOBUS); m.rotation.y=-Math.PI/2;
    scene.add(m); freeze(m); res();
  }));

  await new Promise(res=>L.load(MODEL_DOOR,(g)=>{
    const m=g.scene; fitByHeight(m,2.1);
    m.rotation.set(0,Math.PI/2,0);
    const b0=new THREE.Box3().setFromObject(m);
    const depth=b0.getSize(new THREE.Vector3()).z;
    m.position.set(0,0,D/2-depth*0.5); snapToFrontWall(m,-0.018);
    scene.add(m); freeze(m); res();
  }));

  await new Promise(res=>L.load(MODEL_SHIELD,(g)=>{
    const m=g.scene; fitByHeight(m,0.8);
    m.rotation.y=-Math.PI/2; m.position.copy(POS_SHIELD);
    scene.add(m); freeze(m); res();
  }));
}

/* ---------- музыка ---------- */
function startMusic(){
  try{
    listener=new THREE.AudioListener(); camera.add(listener);
    music=new THREE.Audio(listener);
    const loader=new THREE.AudioLoader(manager);
    loader.load(MUSIC,(b)=>{music.setBuffer(b);music.setLoop(true);music.setVolume(.32);music.play();},undefined,()=>{});
  }catch(e){}
}

/* ---------- XR: фонарь и выход ---------- */
function attachLanternTo(object3D, label){
  // свет
  const light=new THREE.PointLight(0xffb680, LANTERN_INT, LANTERN_DIST);
  light.castShadow=true; light.shadow.mapSize.set(512,512);
  light.position.set(0,-0.02,-0.12);
  object3D.add(light); lanternLights.push(light);

  // модель (если есть)
  new THREE.GLTFLoader(manager).load(MODEL_LANTERN,(g)=>{
    const node=g.scene; fitByHeight(node,LANTERN_SIZE_M);
    node.position.set(0,-0.04,-0.12);
    object3D.add(node); lanternNodes.push(node);
  }, undefined, ()=>{/* нет модели — норм */});

  log('lantern attached →', label);
  hud.classList.add('show'); // показать HUD в VR по умолчанию
}

function addHoldExit(ctrl){
  const start=()=>{ if(holding) return; holding=true; navigator.vibrate?.(20); holdTimer=setTimeout(async ()=>{ navigator.vibrate?.([40,40,40]); await renderer.xr.getSession()?.end(); },1500); };
  const end =()=>{ holding=false; clearTimeout(holdTimer); };
  ctrl.addEventListener('squeezestart',start);
  ctrl.addEventListener('squeezeend',end);
  ctrl.addEventListener('selectstart',start);
  ctrl.addEventListener('selectend',end);
}

function onXRStart(){
  log('sessionstart');
  // ещё затемним общий свет
  [amb,hemi,sun].forEach(l=> l.intensity*=0.35);

  const c0=renderer.xr.getController(0), c1=renderer.xr.getController(1);
  scene.add(c0); scene.add(c1);
  addHoldExit(c0); addHoldExit(c1);

  // пробуем найти правый
  const session=renderer.xr.getSession();
  let rightCtrl=null;
  const pickRight=()=>{
    const inputs=session.inputSources||[];
    const right=inputs.find(i=>i.handedness==='right' && i.targetRayMode!=='gaze');
    if(right){
      rightCtrl = (right===inputs[0])?c0:c1;
      if(rightCtrl) attachLanternTo(rightCtrl,'right controller');
    }
    log('inputs:', inputs.length, 'right found:', !!right);
  };

  session.addEventListener('inputsourceschange', ()=>{
    log('inputsourceschange');
    if(lanternLights.length===0) pickRight();
  });

  // если за 300мс правый так и не определился — вешаем на любой доступный
  setTimeout(()=>{
    if(lanternLights.length===0){
      if(c1) attachLanternTo(c1,'controller#1');
      else if(c0) attachLanternTo(c0,'controller#0');
      else { attachLanternTo(camera,'camera (fallback)'); } // совсем без контроллеров
    }
  },300);

  // дубль-страховка: если через 2с всё равно нет фонаря — точно вешаем на голову
  setTimeout(()=>{
    if(lanternLights.length===0) attachLanternTo(camera,'camera (late fallback)');
  },2000);
}

function onXREnd(){
  log('sessionend');
  clearTimeout(holdTimer); holding=false;
  [amb,hemi,sun].forEach(l=> l.intensity/=0.35);
  lanternLights.forEach(l=>l.parent?.remove(l));
  lanternNodes.forEach(n=>n.parent?.remove(n));
  lanternLights.length=0; lanternNodes.length=0;
  hud.classList.remove('show');
}
</script>
</body>
</html>
