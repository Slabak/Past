<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Комната — портал, 360° камера, сундук, бочки и балки</title>
  <style>
    html, body { height:100%; margin:0; overflow:hidden; background:#000; }
    #overlay, #loading-screen {
      position:fixed; inset:0; display:grid; place-items:center;
      background:radial-gradient(circle at center, rgba(0,0,0,.85), rgba(0,0,0,1));
      color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; z-index:9999;
    }
    #overlay button {
      font-size:18px; padding:14px 24px; border-radius:12px; border:none;
      background:#ffb366; color:#000; cursor:pointer; transition:transform .2s,background .3s;
    }
    #overlay button:hover { transform:scale(1.05); background:#ffd5a3; }
    .portal-wrap { display:flex; flex-direction:column; align-items:center; gap:14px; }
    .portal-text { font-size:1.1rem; letter-spacing:.5px; text-align:center; }
    .portal-ring { width:72px; height:72px; border:4px solid rgba(255,200,100,.45);
      border-top-color:#ffb366; border-radius:50%; animation:spin 1s linear infinite; }
    .bar { width:260px; height:8px; background:rgba(255,255,255,.12); border-radius:8px; overflow:hidden; }
    .bar-fill { height:100%; width:0%; background:#ffb366; transition:width .15s ease; }
    @keyframes spin { to { transform:rotate(360deg); } }
    .fade-out { animation:fadeOut 1s forwards; }
    @keyframes fadeOut { to { opacity:0; visibility:hidden; } }

    /* UI переключения управления */
    #modeToggle {
      position: fixed; top: 14px; right: 14px; z-index: 10000;
      background: rgba(0,0,0,.55); color: #fff; border:1px solid rgba(255,255,255,.2);
      padding: 10px 12px; border-radius: 10px; font-size: 14px; cursor: pointer;
      backdrop-filter: blur(6px);
      display: none;
    }
    #toast {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 16px; padding: 10px 14px; border-radius: 10px; color: #000;
      background: #ffd48a; z-index: 10000; font-size: 14px; display: none;
    }
  </style>
</head>
<body>
  <div id="overlay"><button id="start">Войти в комнату</button></div>

  <div id="loading-screen" style="display:none;">
    <div class="portal-wrap">
      <div class="portal-text">Переносимся через портал… <span id="progress">0%</span></div>
      <div class="bar"><div id="bar-fill" class="bar-fill"></div></div>
      <div class="portal-ring"></div>
    </div>
  </div>

  <!-- переключение управления -->
  <button id="modeToggle">Управление: ПАЛЕЦ</button>
  <div id="toast"></div>

  <!-- three -->
  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>

  <script>
    /** ОСИ СЦЕНЫ
     * +Z — к ПЕРЕДНЕЙ стене (где зеркало).
     * +X — к ПРАВОЙ стене.
     *  Y — вверх.
     */

    // ---- ПАРАМЕТРЫ (можно править) ----
    // Сундук (как в твоём шаблоне)
    const CHEST_SIZE_MULT     = 1.5;   // множитель размера (целевая диагональ 1.2м * этот множитель)
    const CHEST_WALLOFFSET_X  = 0.45;  // отступ от левой стены
    const CHEST_Z             = 1.10;  // положение вдоль левой стены (к передней = +Z)

    // Бочки (в другом углу левой стены)
    const BARRELS_TARGET_HEIGHT = 1.30; // желаемая высота (м)
    const BARRELS_WALLOFFSET_X  = 0.45; // отступ от левой стены
    const BARRELS_Z             = -1.10;// ближе к задней стене
    const BARRELS_ROT_LEFT_90   = true; // повернуть вдоль стены

    // БАЛКИ (plank.glb)
    const BEAM_THICKNESS   = 0.12; // толщина/ширина балки (м) ~ 12 см
    const BEAM_INSET_WALL  = 0.03; // отступ от стен (чтобы не пересекалось)
    const BEAM_INSET_CEIL  = 0.02; // зазор от потолка
    const POST_FLOOR_GAP   = 0.00; // приподнять стойки от пола при надобности

    let scene, camera, renderer;
    let orbitControls = null;
    let deviceControls = null; // наш встроенный контрол
    let activeControls = null;

    let listener, bgm, portalSound, fallbackWood = null;
    const w = 4, d = 4, h = 3; // размеры комнаты

    // -------- утилиты UI --------
    const $ = sel => document.querySelector(sel);
    function toast(msg, ms=2200) {
      const el = $('#toast');
      el.textContent = msg; el.style.display = 'block';
      clearTimeout(toast._t); toast._t = setTimeout(()=> el.style.display='none', ms);
    }

    // -------- АУДИО --------
    function playPortal() {
      try {
        const loader = new THREE.AudioLoader();
        portalSound = new THREE.Audio(listener);
        loader.load('assets/music/portal.mp3', (buffer) => {
          portalSound.setBuffer(buffer); portalSound.setLoop(false);
          portalSound.setVolume(0.9); portalSound.play();
        });
      } catch {}
    }
    function startBGM() {
      try {
        const ac = listener?.context; if (ac && ac.state === 'suspended') ac.resume();
        const loader = new THREE.AudioLoader();
        bgm = new THREE.Audio(listener);
        loader.load('assets/music/music.mp3', (buffer) => {
          bgm.setBuffer(buffer); bgm.setLoop(true); bgm.setVolume(0.35); bgm.play();
        }, undefined, () => console.warn('music.mp3 не найден'));
      } catch {}
    }

    // ---- ВСТРОЕННЫЙ контрол вращения телефоном (без внешних файлов) ----
    function makeDeviceControls(camera) {
      let alphaOffset = 0; // для калибровки "смотреть вперёд"
      let lastEvent = null;
      const zee = new THREE.Vector3(0, 0, 1);
      const euler = new THREE.Euler();
      const q0 = new THREE.Quaternion();
      const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 вокруг X
      let screenOrientation = (window.orientation || 0);

      function onScreenOrientationChangeEvent() {
        screenOrientation = (window.orientation || 0);
      }
      function onDeviceOrientationChangeEvent(e) {
        lastEvent = e;
      }
      function setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {
        euler.set(beta, alpha, -gamma, 'YXZ');
        quaternion.setFromEuler(euler);
        quaternion.multiply(q1);
        quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
      }

      window.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);
      window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, true);

      return {
        update() {
          if (!lastEvent) return;
          const alpha = THREE.MathUtils.degToRad(lastEvent.alpha || 0) + alphaOffset;
          const beta  = THREE.MathUtils.degToRad(lastEvent.beta  || 0);
          const gamma = THREE.MathUtils.degToRad(lastEvent.gamma || 0);
          const orient = THREE.MathUtils.degToRad(screenOrientation || 0);
          setObjectQuaternion(camera.quaternion, alpha, beta, gamma, orient);
        },
        disconnect() {
          window.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent, true);
          window.removeEventListener('orientationchange', onScreenOrientationChangeEvent, false);
        },
        calibrateToCurrentHeading() {
          if (!lastEvent) return;
          const heading = THREE.MathUtils.degToRad(lastEvent.alpha || 0);
          alphaOffset = -heading;
        }
      };
    }

    function init() {
      const overlay = $('#overlay');
      const loadingScreen = $('#loading-screen');
      const progressText = $('#progress');
      const barFill = $('#bar-fill');
      const startBtn = $('#start');
      const modeBtn = $('#modeToggle');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x100806);
      scene.fog = new THREE.Fog(0x1a0f0a, 5, 12);

      // КАМЕРА: центр комнаты, 360°
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 50);
      camera.position.set(0, 1.6, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      document.body.appendChild(renderer.domElement);

      // LIGHT
      const hemi = new THREE.HemisphereLight(0xffd9b0, 0x1a0f0a, 0.35); scene.add(hemi);
      const ambient = new THREE.AmbientLight(0xffd7aa, 0.22); scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffb366, 1.35);
      dir.position.set(-2.5, 3.5, 1.5);
      dir.castShadow = true; dir.shadow.mapSize.set(2048, 2048); dir.shadow.radius = 6;
      scene.add(dir);
      const fire = new THREE.PointLight(0xffa860, 0.6, 6); fire.position.set(-1.5, 1.2, 1.2); scene.add(fire);

      // AUDIO LISTENER
      listener = new THREE.AudioListener(); camera.add(listener);

      // КНОПКА СТАРТА -> ПОРТАЛ/ЗАГРУЗКА
      startBtn.addEventListener('click', () => {
        overlay.style.display = 'none';
        loadingScreen.style.display = 'grid';

        loadAllAssetsWithProgress((pct) => {
          progressText.textContent = `${pct}%`;
          barFill.style.width = `${pct}%`;
        }).then(() => {
          playPortal();
          loadingScreen.classList.add('fade-out');
          setTimeout(() => {
            loadingScreen.remove();
            startBGM();
            // показать кнопку переключения управления
            modeBtn.style.display = 'block';
            // по умолчанию — ПАЛЕЦ (орбита)
            enableOrbitControls();
          }, 1000);
        });
      }, { once: true });

      // ПЕРЕКЛЮЧЕНИЕ РЕЖИМОВ
      modeBtn.addEventListener('click', async () => {
        if (activeControls === deviceControls) {
          enableOrbitControls();
          modeBtn.textContent = 'Управление: ПАЛЕЦ';
          toast('Режим: палец (свайп-инверсия)');
        } else {
          const ok = await tryEnableDeviceControls();
          if (ok) {
            modeBtn.textContent = 'Управление: ТЕЛЕФОН';
            toast('Режим: телефоном (гироскоп). Долгий тап — калибровка.');
          } else {
            toast('Доступ к датчикам отклонён — остаётся режим пальцем');
          }
        }
      });

      // Долгий тап по кнопке — калибровка "смотреть вперёд"
      modeBtn.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (deviceControls && activeControls === deviceControls) {
          deviceControls.calibrateToCurrentHeading();
          toast('Калибровка: взгляд вперёд сохранён');
        }
      });

      // ресайз + анимация
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      (function animate(){
        requestAnimationFrame(animate);
        fire.intensity = 0.55 + Math.sin(performance.now() * 0.003) * 0.15;
        if (activeControls && activeControls.update) activeControls.update();
        renderer.render(scene, camera);
      })();
    }

    // ---- включение/выключение контролов ----
    function enableOrbitControls() {
      // уничтожаем device
      if (deviceControls && deviceControls.disconnect) { deviceControls.disconnect(); deviceControls = null; }
      // создаём/настраиваем orbit
      if (!orbitControls) {
        orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.target.set(0, 1.5, 0);
        orbitControls.enableZoom = false;
        orbitControls.enablePan  = false;
        orbitControls.enableRotate = true;
        orbitControls.minAzimuthAngle = -Infinity;
        orbitControls.maxAzimuthAngle =  Infinity;
        orbitControls.minPolarAngle = THREE.MathUtils.degToRad(2);
        orbitControls.maxPolarAngle = THREE.MathUtils.degToRad(178);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.12;
        orbitControls.rotateSpeed   = -0.8; // инверсия "как скролл"
        orbitControls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
      }
      activeControls = orbitControls;
    }

    async function tryEnableDeviceControls() {
      // iOS 13+: запрос разрешения
      try {
        if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
          const perm = await DeviceOrientationEvent.requestPermission();
          if (perm !== 'granted') return false;
        }
      } catch (e) {
        console.warn(e);
        return false;
      }
      // создаём встроенный контрол
      deviceControls = makeDeviceControls(camera);
      // выключаем orbit
      if (orbitControls) { orbitControls.dispose(); orbitControls = null; }
      activeControls = deviceControls;
      return true;
    }

    // ---- Утилита починки материалов/текстур ----
    function fixMaterials(root) {
      root.traverse(obj => {
        if (!obj.isMesh) return;
        const apply = (mat) => {
          if (!mat) return;
          if (mat.map) {
            mat.map.colorSpace = THREE.SRGBColorSpace;
            mat.map.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 8;
          } else if (fallbackWood) {
            mat.map = fallbackWood; mat.color?.set?.(0xffffff);
          } else {
            mat.color?.set?.(0x8a5a3a);
          }
          if (mat.roughness === undefined) mat.roughness = 0.85;
          if (mat.metalness === undefined) mat.metalness = 0.0;
          if ('vertexColors' in mat) mat.vertexColors = false;
          mat.needsUpdate = true;
        };
        if (Array.isArray(obj.material)) obj.material.forEach(apply);
        else apply(obj.material);
        obj.castShadow = true; obj.receiveShadow = true;
      });
    }

    // ======= Вспомогательные функции для балок (plank.glb) =======
    function preparePlankUnit(plankScene) {
      // центрируем
      const box = new THREE.Box3().setFromObject(plankScene);
      plankScene.position.sub(box.getCenter(new THREE.Vector3()));

      // определить «длинную ось»
      const size = box.getSize(new THREE.Vector3());
      let maxAxis = 'y';
      if (size.x >= size.y && size.x >= size.z) maxAxis = 'x';
      else if (size.z >= size.y && size.z >= size.x) maxAxis = 'z';

      // Повернуть так, чтобы длина шла по +Y
      if (maxAxis === 'x') plankScene.rotation.set(0, 0, Math.PI/2);
      else if (maxAxis === 'z') plankScene.rotation.set(-Math.PI/2, 0, 0);

      // Нормировка длины до 1м
      const box2 = new THREE.Box3().setFromObject(plankScene);
      const size2 = box2.getSize(new THREE.Vector3());
      const lengthY = Math.max(size2.y, 1e-6);
      const scaleToUnit = 1 / lengthY;
      plankScene.scale.multiplyScalar(scaleToUnit);

      // Базовые поперечники после нормировки
      const baseBox = new THREE.Box3().setFromObject(plankScene);
      const baseSize = baseBox.getSize(new THREE.Vector3());
      const baseCrossX = Math.max(baseSize.x, 1e-6);
      const baseCrossZ = Math.max(baseSize.z, 1e-6);

      const unit = new THREE.Group();
      unit.add(plankScene);

      function spawnBeamBetween(start, end, thickness = BEAM_THICKNESS) {
        const clone = unit.clone(true);
        const dir = new THREE.Vector3().subVectors(end, start);
        const len = dir.length();
        if (len < 1e-6) return null;
        const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

        // масштаб: по Y — длина, по X/Z — толщина
        const sx = thickness / baseCrossX;
        const sy = len;
        const sz = thickness / baseCrossZ;
        clone.scale.set(sx, sy, sz);

        // ориентация: +Y → dir
        const q = new THREE.QuaternionsetFromUnitVectors
        ? new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize())
        : (function(){ const qq=new THREE.Quaternion(); qq.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize()); return qq; })();
        clone.quaternion.copy(q);

        clone.position.copy(mid);

        clone.traverse(o => { if (o.isMesh) { o.castShadow = o.receiveShadow = true; } });
        fixMaterials(clone);

        scene.add(clone);
        return clone;
      }

      return { spawnBeamBetween };
    }

    // Загрузка: текстуры, комната, сундук, бочки, балки
    function loadAllAssetsWithProgress(onProgress) {
      return new Promise((resolve) => {
        const manager = new THREE.LoadingManager(
          () => resolve(),
          (url, itemsLoaded, itemsTotal) => {
            const pct = Math.min(100, Math.floor(itemsLoaded / itemsTotal * 100));
            onProgress?.(pct);
          },
          (url) => console.warn('Ошибка загрузки:', url)
        );

        // TEXTURES
        const tl = new THREE.TextureLoader(manager);
        const floorTex = tl.load('assets/textures/floor.jpg'); floorTex.colorSpace = THREE.SRGBColorSpace;
        floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping; floorTex.repeat.set(2, 2);
        const wallTex  = tl.load('assets/textures/wall.jpg?v=15'); wallTex.colorSpace = THREE.SRGBColorSpace;
        wallTex.wrapS = wallTex.wrapT = THREE.ClampToEdgeWrapping;
        const mirrorTex = tl.load('assets/textures/mirror.jpg'); mirrorTex.colorSpace = THREE.SRGBColorSpace;
        // запасная древесная текстура
        fallbackWood = tl.load('assets/textures/wood.jpg', t => {
          t.colorSpace = THREE.SRGBColorSpace;
          t.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 8;
        });

        // ROOM (слегка опускаем стены)
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(w, d),
          new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.9 }));
        floor.rotation.x = -Math.PI/2; floor.position.y = 0.0005;
        floor.receiveShadow = true; scene.add(floor);

        const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 1.0 });
        const walls = [
          [0, h/2 - 0.01, -d/2, 0],           // back (зеркало здесь)
          [0, h/2 - 0.01,  d/2, Math.PI],     // front
          [-w/2, h/2 - 0.01, 0,  Math.PI/2],  // left
          [ w/2, h/2 - 0.01, 0, -Math.PI/2],  // right
        ];
        walls.forEach(([x,y,z,ry])=>{
          const wall = new THREE.Mesh(new THREE.PlaneGeometry(ry ? d : w, h + 0.02), wallMat);
          wall.position.set(x,y,z); if (ry) wall.rotation.y = ry;
          wall.receiveShadow = true; scene.add(wall);
        });

        const mirror = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.6),
          new THREE.MeshStandardMaterial({ map: mirrorTex, metalness: 0.85, roughness: 0.22 }));
        mirror.position.set(0, 1.5, -d/2 + 0.01); scene.add(mirror);

        // MODELS
        const gltfLoader = new THREE.GLTFLoader(manager);

        // ---- СУНДУК (по твоему образцу) ----
        gltfLoader.load('assets/models/chest.glb', (gltf) => {
          const chest = gltf.scene;

          // 1) Центр
          const box0 = new THREE.Box3().setFromObject(chest);
          chest.position.sub(box0.getCenter(new THREE.Vector3()));

          // 2) Масштаб
          const targetDiag = 1.2 * CHEST_SIZE_MULT;
          const diag0 = box0.getSize(new THREE.Vector3()).length();
          const s = diag0 > 0 ? targetDiag / diag0 : 1;
          chest.scale.setScalar(s);

          // 3) На пол
          const box1 = new THREE.Box3().setFromObject(chest);
          chest.position.y -= box1.min.y;

          // 4) Позиция (левая стена, ближе к передней)
          chest.position.x = -w/2 + CHEST_WALLOFFSET_X;
          chest.position.z = CHEST_Z;

          // 5) Поворот вдоль левой стены
          chest.rotation.y = Math.PI;

          fixMaterials(chest);
          scene.add(chest);
        }, undefined, (err)=>console.warn('Ошибка загрузки chest.glb', err));

        // ---- БОЧКИ (в другом углу той же стены) ----
        const loadBarrels = (url) => gltfLoader.load(url, (gltf2) => {
          const barrels = gltf2.scene;

          // центр и масштаб по целевой высоте
          const g0 = new THREE.Box3().setFromObject(barrels);
          barrels.position.sub(g0.getCenter(new THREE.Vector3()));
          const groupH = g0.getSize(new THREE.Vector3()).y || 1;
          const scale = BARRELS_TARGET_HEIGHT / groupH;
          barrels.scale.setScalar(scale);

          // на пол
          const g1 = new THREE.Box3().setFromObject(barrels);
          barrels.position.y -= g1.min.y;

          // координаты у ЛЕВОГО-ЗАДНЕГО угла
          barrels.position.x = -w/2 + BARRELS_WALLOFFSET_X;
          barrels.position.z = BARRELS_Z;

          if (BARRELS_ROT_LEFT_90) barrels.rotation.y = Math.PI / 2;

          fixMaterials(barrels);
          scene.add(barrels);
        }, undefined, (err)=>console.warn('Ошибка загрузки', url, err));

        // быстрая лёгкая версия (если есть), и/или старая
        loadBarrels('assets/models/barrel_light.glb');
        loadBarrels('assets/models/barrel.glb');

        // ---- БАЛКИ: грузим plank.glb и расставляем 4 стойки + 4 ригеля ----
        gltfLoader.load('assets/models/plank.glb', (gltfPlank) => {
          const plankRoot = gltfPlank.scene;

          // подготовка юнита
          const prep = (function preparePlankUnit(plankScene) {
            // центр
            const box = new THREE.Box3().setFromObject(plankScene);
            plankScene.position.sub(box.getCenter(new THREE.Vector3()));
            // длинная ось
            const size = box.getSize(new THREE.Vector3());
            let maxAxis = 'y';
            if (size.x >= size.y && size.x >= size.z) maxAxis = 'x';
            else if (size.z >= size.y && size.z >= size.x) maxAxis = 'z';
            if (maxAxis === 'x') plankScene.rotation.set(0, 0, Math.PI/2);
            else if (maxAxis === 'z') plankScene.rotation.set(-Math.PI/2, 0, 0);
            // нормировка длины до 1м
            const box2 = new THREE.Box3().setFromObject(plankScene);
            const size2 = box2.getSize(new THREE.Vector3());
            const lengthY = Math.max(size2.y, 1e-6);
            plankScene.scale.multiplyScalar(1/lengthY);
            const baseBox = new THREE.Box3().setFromObject(plankScene);
            const baseSize = baseBox.getSize(new THREE.Vector3());
            const baseCrossX = Math.max(baseSize.x, 1e-6);
            const baseCrossZ = Math.max(baseSize.z, 1e-6);

            const unit = new THREE.Group(); unit.add(plankScene);

            function spawnBetween(start, end, thickness = BEAM_THICKNESS) {
              const clone = unit.clone(true);
              const dir = new THREE.Vector3().subVectors(end, start);
              const len = dir.length(); if (len < 1e-6) return null;
              const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

              const sx = thickness / baseCrossX;
              const sy = len;
              const sz = thickness / baseCrossZ;
              clone.scale.set(sx, sy, sz);

              const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
              clone.quaternion.copy(q);
              clone.position.copy(mid);

              clone.traverse(o => { if (o.isMesh) { o.castShadow = o.receiveShadow = true; } });
              fixMaterials(clone);
              scene.add(clone);
              return clone;
            }
            return { spawnBetween };
          })(plankRoot);

          // координаты углов с отступами
          const xL = -w/2 + BEAM_INSET_WALL;
          const xR =  w/2 - BEAM_INSET_WALL;
          const zB = -d/2 + BEAM_INSET_WALL; // back (зеркало)
          const zF =  d/2 - BEAM_INSET_WALL; // front

          const y0 = 0 + POST_FLOOR_GAP;
          const yT = h - BEAM_INSET_CEIL;
          const yH = yT;

          // 4 вертикальные стойки
          prep.spawnBetween(new THREE.Vector3(xL, y0, zB), new THREE.Vector3(xL, yT, zB));
          prep.spawnBetween(new THREE.Vector3(xR, y0, zB), new THREE.Vector3(xR, yT, zB));
          prep.spawnBetween(new THREE.Vector3(xL, y0, zF), new THREE.Vector3(xL, yT, zF));
          prep.spawnBetween(new THREE.Vector3(xR, y0, zF), new THREE.Vector3(xR, yT, zF));

          // 4 горизонтальные под потолком (обрамление)
          prep.spawnBetween(new THREE.Vector3(xL, yH, zB), new THREE.Vector3(xR, yH, zB)); // задняя
          prep.spawnBetween(new THREE.Vector3(xL, yH, zF), new THREE.Vector3(xR, yH, zF)); // передняя
          prep.spawnBetween(new THREE.Vector3(xL, yH, zB), new THREE.Vector3(xL, yH, zF)); // левая
          prep.spawnBetween(new THREE.Vector3(xR, yH, zB), new THREE.Vector3(xR, yH, zF)); // правая
        }, undefined, (err)=>console.warn('Не удалось загрузить assets/models/plank.glb', err));

        // страховка от вечного портала
        setTimeout(()=>resolve(), 12000);
      });
    }

    // старт
    window.addEventListener('load', init);
  </script>
</body>
</html>
