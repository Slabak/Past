<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Комната — портал, камера, сундук, бочки, балки, потолок и СТОЛ</title>
  <style>
    html, body { height:100%; margin:0; overflow:hidden; background:#000; }
    #overlay, #loading-screen {
      position:fixed; inset:0; display:grid; place-items:center;
      background:radial-gradient(circle at center, rgba(0,0,0,.85), rgba(0,0,0,1));
      color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; z-index:9999;
    }
    #overlay button {
      font-size:18px; padding:14px 24px; border-radius:12px; border:none;
      background:#ffb366; color:#000; cursor:pointer; transition:transform .2s,background .3s;
    }
    #overlay button:hover { transform:scale(1.05); background:#ffd5a3; }
    .portal-wrap { display:flex; flex-direction:column; align-items:center; gap:14px; }
    .portal-text { font-size:1.1rem; letter-spacing:.5px; text-align:center; }
    .portal-ring { width:72px; height:72px; border:4px solid rgba(255,200,100,.45);
      border-top-color:#ffb366; border-radius:50%; animation:spin 1s linear infinite; }
    .bar { width:260px; height:8px; background:rgba(255,255,255,.12); border-radius:8px; overflow:hidden; }
    .bar-fill { height:100%; width:0%; background:#ffb366; transition:width .15s ease; }
    @keyframes spin { to { transform:rotate(360deg); } }
    .fade-out { animation:fadeOut 1s forwards; }
    @keyframes fadeOut { to { opacity:0; visibility:hidden; } }

    #modeToggle {
      position: fixed; top: 14px; right: 14px; z-index: 10000;
      background: rgba(0,0,0,.55); color: #fff; border:1px solid rgba(255,255,255,.2);
      padding: 10px 12px; border-radius: 10px; font-size: 14px; cursor: pointer;
      backdrop-filter: blur(6px); display: none;
    }
    #toast {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 16px; padding: 10px 14px; border-radius: 10px; color: #000;
      background: #ffd48a; z-index: 10000; font-size: 14px; display: none;
    }
  </style>
</head>
<body>
  <div id="overlay"><button id="start">Войти в комнату</button></div>

  <div id="loading-screen" style="display:none;">
    <div class="portal-wrap">
      <div class="portal-text">Переносимся через портал… <span id="progress">0%</span></div>
      <div class="bar"><div id="bar-fill" class="bar-fill"></div></div>
      <div class="portal-ring"></div>
    </div>
  </div>

  <button id="modeToggle">Управление: ПАЛЕЦ</button>
  <div id="toast"></div>

  <!-- libs -->
  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>

  <script>
    // ---- Параметры комнаты ----
    const w = 4, d = 4, h = 3; // метры

    // Сундук (слева, передний сектор)
    const CHEST_SIZE_MULT     = 1.5;
    const CHEST_WALLOFFSET_X  = 0.45;
    const CHEST_Z             = 1.10;

    // Бочки (слева, задний сектор)
    const BARRELS_TARGET_HEIGHT = 1.30;
    const BARRELS_WALLOFFSET_X  = 0.45;
    const BARRELS_Z             = -1.10;
    const BARRELS_ROT_LEFT_90   = true;

    // ---- Глобальные ----
    let scene, camera, renderer;
    let orbitControls = null, deviceControls = null, activeControls = null;
    let listener, bgm, portalSound, fallbackWood = null;

    const $ = s => document.querySelector(s);
    const toast = (m,ms=2200)=>{const t=$('#toast'); t.textContent=m;t.style.display='block';clearTimeout(toast._t);toast._t=setTimeout(()=>t.style.display='none',ms);};

    // ---- Аудио ----
    function playPortal(){ try{ const l=new THREE.AudioLoader(); portalSound=new THREE.Audio(listener);
      l.load('assets/music/portal.mp3',buf=>{portalSound.setBuffer(buf);portalSound.setLoop(false);portalSound.setVolume(0.9);portalSound.play();}); }catch{} }
    function startBGM(){ try{ const ac=listener?.context; if(ac&&ac.state==='suspended') ac.resume();
      const l=new THREE.AudioLoader(); bgm=new THREE.Audio(listener);
      l.load('assets/music/music.mp3',buf=>{bgm.setBuffer(buf);bgm.setLoop(true);bgm.setVolume(0.35);bgm.play();},undefined,()=>console.warn('music.mp3 не найден')); }catch{} }

    // ---- DeviceOrientation (по желанию) ----
    function makeDeviceControls(cam){
      let alphaOffset=0,last=null;
      const zee=new THREE.Vector3(0,0,1), euler=new THREE.Euler(), q0=new THREE.Quaternion(),
            q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
      let so=(window.orientation||0);
      function onSO(){so=(window.orientation||0);} function onDO(e){last=e;}
      function setQ(q,a,b,g,o){ euler.set(b,a,-g,'YXZ'); q.setFromEuler(euler); q.multiply(q1); q.multiply(q0.setFromAxisAngle(zee,-o)); }
      window.addEventListener('orientationchange', onSO, false);
      window.addEventListener('deviceorientation', onDO, true);
      return {
        update(){ if(!last) return;
          const a=THREE.MathUtils.degToRad(last.alpha||0)+alphaOffset;
          const b=THREE.MathUtils.degToRad(last.beta ||0);
          const g=THREE.MathUtils.degToRad(last.gamma||0);
          const o=THREE.MathUtils.degToRad(so||0);
          setQ(cam.quaternion,a,b,g,o);
        },
        disconnect(){ window.removeEventListener('deviceorientation', onDO, true); window.removeEventListener('orientationchange', onSO, false); },
        calibrateToCurrentHeading(){ if(!last) return; alphaOffset = -THREE.MathUtils.degToRad(last.alpha||0); }
      };
    }

    function init(){
      const overlay=$('#overlay'), loading=$('#loading-screen'), startBtn=$('#start'),
            progressText=$('#progress'), barFill=$('#bar-fill'), modeBtn=$('#modeToggle');

      scene=new THREE.Scene();
      scene.background=new THREE.Color(0x100806);
      scene.fog=new THREE.Fog(0x1a0f0a,5,12);

      // Камера ставим в центр комнаты (игрок на месте, только «вертит головой/пальцем»)
      camera=new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, .05, 50);
      camera.position.set(0,1.6,0);

      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled=true;
      renderer.shadowMap.type=THREE.PCFSoftShadowMap;
      renderer.outputColorSpace=THREE.SRGBColorSpace;
      renderer.toneMapping=THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure=1.05;
      document.body.appendChild(renderer.domElement);

      // Свет
      const hemi=new THREE.HemisphereLight(0xffd9b0,0x1a0f0a,0.35); scene.add(hemi);
      const ambient=new THREE.AmbientLight(0xffd7aa,0.22); scene.add(ambient);
      const dir=new THREE.DirectionalLight(0xffb366,1.35); dir.position.set(-2.5,3.5,1.5);
      dir.castShadow=true; dir.shadow.mapSize.set(2048,2048); dir.shadow.radius=6; scene.add(dir);
      const fire=new THREE.PointLight(0xffa860,0.6,6); fire.position.set(-1.5,1.2,1.2); scene.add(fire);

      // Аудио
      listener=new THREE.AudioListener(); camera.add(listener);

      // Кнопка «вход»
      startBtn.addEventListener('click', ()=>{
        overlay.style.display='none'; loading.style.display='grid';
        loadAllAssetsWithProgress(p=>{progressText.textContent=`${p}%`; barFill.style.width=`${p}%`;})
        .then(()=>{ playPortal(); loading.classList.add('fade-out');
          setTimeout(()=>{ loading.remove(); startBGM(); modeBtn.style.display='block'; enableOrbitControls(); },1000);
        });
      }, {once:true});

      // Переключатель режимов управления
      modeBtn.addEventListener('click', async ()=>{
        if(activeControls===deviceControls){ enableOrbitControls(); modeBtn.textContent='Управление: ПАЛЕЦ'; toast('Режим: палец (свайп-инверсия)'); }
        else { const ok=await tryEnableDeviceControls();
          if(ok){ modeBtn.textContent='Управление: ТЕЛЕФОН'; toast('Режим: телефоном. Долгий тап — калибровка.'); }
          else { toast('Доступ к датчикам отклонён — остаётся режим пальцем'); }
        }
      });
      modeBtn.addEventListener('contextmenu',e=>{ e.preventDefault(); if(deviceControls&&activeControls===deviceControls){ deviceControls.calibrateToCurrentHeading(); toast('Калибровка выполнена'); }});

      // Resize
      window.addEventListener('resize', ()=>{
        camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Рендер-луп
      (function anim(){ requestAnimationFrame(anim);
        fire.intensity=0.55+Math.sin(performance.now()*0.003)*0.15;
        if(activeControls&&activeControls.update) activeControls.update();
        renderer.render(scene,camera);
      })();
    }

    function enableOrbitControls(){
      if(deviceControls&&deviceControls.disconnect){ deviceControls.disconnect(); deviceControls=null; }
      if(!orbitControls){
        orbitControls=new THREE.OrbitControls(camera, renderer.domElement);
        orbitControls.target.set(0,1.5,0);
        orbitControls.enableZoom=false; orbitControls.enablePan=false; orbitControls.enableRotate=true;
        // 360° поворот и «скроллинговая» инверсия по пальцу
        orbitControls.minAzimuthAngle=-Infinity; orbitControls.maxAzimuthAngle=Infinity;
        orbitControls.minPolarAngle=THREE.MathUtils.degToRad(2); orbitControls.maxPolarAngle=THREE.MathUtils.degToRad(178);
        orbitControls.enableDamping=true; orbitControls.dampingFactor=0.12; orbitControls.rotateSpeed=-0.8;
        orbitControls.touches={ONE:THREE.TOUCH.ROTATE, TWO:THREE.TOUCH.DOLLY_PAN};
      }
      activeControls=orbitControls;
    }

    async function tryEnableDeviceControls(){
      try{
        if(window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission==='function'){
          const perm=await DeviceOrientationEvent.requestPermission(); if(perm!=='granted') return false;
        }
      }catch(e){ console.warn(e); return false; }
      deviceControls=makeDeviceControls(camera);
      if(orbitControls){ orbitControls.dispose(); orbitControls=null; }
      activeControls=deviceControls; return true;
    }

    // Материалы для импортированных моделей
    function fixMaterials(root){
      root.traverse(obj=>{
        if(!obj.isMesh) return;
        const apply=mat=>{
          if(!mat) return;
          if(mat.map){ mat.map.colorSpace=THREE.SRGBColorSpace; mat.map.anisotropy=renderer.capabilities.getMaxAnisotropy?.()||8; }
          else if(fallbackWood){ mat.map=fallbackWood; mat.color?.set?.(0xffffff); }
          else { mat.color?.set?.(0x8a5a3a); }
          if(mat.roughness===undefined) mat.roughness=0.85;
          if(mat.metalness===undefined) mat.metalness=0.0;
          if('vertexColors' in mat) mat.vertexColors=false;
          mat.needsUpdate=true;
        };
        if(Array.isArray(obj.material)) obj.material.forEach(apply); else apply(obj.material);
        obj.castShadow=true; obj.receiveShadow=true;
      });
    }

    // Загрузка ассетов с прогрессом
    function loadAllAssetsWithProgress(onProgress){
      return new Promise((resolve)=>{
        const manager=new THREE.LoadingManager(
          ()=>resolve(),
          (url,loaded,total)=>{ onProgress?.(Math.min(100, Math.floor(loaded/total*100))); },
          (url)=>console.warn('Ошибка загрузки:', url)
        );

        // Текстуры
        const tl=new THREE.TextureLoader(manager);
        const floorTex  = tl.load('assets/textures/floor.jpg'); floorTex.colorSpace=THREE.SRGBColorSpace; floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2);
        const wallTex   = tl.load('assets/textures/wall.jpg?v=23'); wallTex.colorSpace=THREE.SRGBColorSpace; wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping;
        const mirrorTex = tl.load('assets/textures/mirror.jpg'); mirrorTex.colorSpace=THREE.SRGBColorSpace;
        const ceilTex   = tl.load('assets/textures/potolok.jpg'); ceilTex.colorSpace=THREE.SRGBColorSpace;
        fallbackWood    = tl.load('assets/textures/wood.jpg', t=>{t.colorSpace=THREE.SRGBColorSpace; t.anisotropy=renderer.capabilities.getMaxAnisotropy?.()||8;});

        // Геометрия комнаты
        const floor=new THREE.Mesh(new THREE.PlaneGeometry(w,d), new THREE.MeshStandardMaterial({map:floorTex, roughness:0.9}));
        floor.rotation.x=-Math.PI/2; floor.position.y=0.0005; floor.receiveShadow=true; scene.add(floor);

        const wallMat=new THREE.MeshStandardMaterial({map:wallTex, roughness:1.0});
        const walls=[[0,h/2-0.01,-d/2,0],[0,h/2-0.01,d/2,Math.PI],[-w/2,h/2-0.01,0,Math.PI/2],[w/2,h/2-0.01,0,-Math.PI/2]];
        walls.forEach(([x,y,z,ry])=>{ const wall=new THREE.Mesh(new THREE.PlaneGeometry(ry?d:w,h+0.02), wallMat); wall.position.set(x,y,z); if(ry) wall.rotation.y=ry; wall.receiveShadow=true; scene.add(wall); });

        const ceilMat = new THREE.MeshStandardMaterial({ map: ceilTex, roughness: 0.9, metalness: 0.0 });
        const ceil = new THREE.Mesh(new THREE.PlaneGeometry(w, d), ceilMat);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.set(0, h - 0.001, 0);
        ceil.receiveShadow = true;
        scene.add(ceil);

        const mirror=new THREE.Mesh(new THREE.PlaneGeometry(0.9,0.6), new THREE.MeshStandardMaterial({map:mirrorTex, metalness:0.85, roughness:0.22}));
        mirror.position.set(0,1.5,-d/2+0.01); scene.add(mirror);

        // Загрузчик моделей
        const gltfLoader=new THREE.GLTFLoader(manager);

        // Сундук
        gltfLoader.load('assets/models/chest.glb',(g)=>{
          const chest=g.scene;
          const b0=new THREE.Box3().setFromObject(chest); chest.position.sub(b0.getCenter(new THREE.Vector3()));
          const target=1.2*CHEST_SIZE_MULT, diag=b0.getSize(new THREE.Vector3()).length(); chest.scale.setScalar(diag>0? target/diag:1);
          const b1=new THREE.Box3().setFromObject(chest); chest.position.y-=b1.min.y;
          chest.position.x=-w/2+CHEST_WALLOFFSET_X; chest.position.z=CHEST_Z; chest.rotation.y=Math.PI;
          fixMaterials(chest); scene.add(chest);
        }, undefined, e=>console.warn('Не удалось загрузить сундук:', e));

        // Бочки (лёгкие версии; если одной нет — просто пропустится)
        const loadBarrels=url=>gltfLoader.load(url,(g)=>{
          const barrels=g.scene;
          const b0=new THREE.Box3().setFromObject(barrels); barrels.position.sub(b0.getCenter(new THREE.Vector3()));
          const H=b0.getSize(new THREE.Vector3()).y||1; barrels.scale.setScalar(BARRELS_TARGET_HEIGHT/H);
          const b1=new THREE.Box3().setFromObject(barrels); barrels.position.y-=b1.min.y;
          barrels.position.x=-w/2+BARRELS_WALLOFFSET_X; barrels.position.z=BARRELS_Z; if(BARRELS_ROT_LEFT_90) barrels.rotation.y=Math.PI/2;
          fixMaterials(barrels); scene.add(barrels);
        }, undefined, (e)=>console.warn('Ошибка бочек',url,e));
        loadBarrels('assets/models/barrel_light.glb');
        loadBarrels('assets/models/barrel.glb');

        // СТОЛ — новый объект под зеркалом у задней стены
        gltfLoader.load('assets/models/table.glb', (g)=>{
          const table = g.scene;

          // материалы/тени
          table.traverse(o=>{
            if(o.isMesh){
              o.castShadow = true; o.receiveShadow = true;
              const m=o.material;
              if(m && m.map){
                m.map.colorSpace = THREE.SRGBColorSpace;
                m.map.anisotropy = renderer.capabilities.getMaxAnisotropy?.()||8;
              }
              if(m && m.roughness===undefined) m.roughness=0.85;
              if(m && m.metalness===undefined) m.metalness=0.0;
            }
          });

          // 1) центрируем
          const b0 = new THREE.Box3().setFromObject(table);
          const c0 = b0.getCenter(new THREE.Vector3());
          table.position.sub(c0);

          // 2) масштаб до нормальной высоты ~0.78 м
          const TARGET_HEIGHT = 0.78;
          const size0 = b0.getSize(new THREE.Vector3());
          const s = (size0.y>0) ? TARGET_HEIGHT / size0.y : 1;
          table.scale.setScalar(s);

          // 3) поставить на пол
          const b1 = new THREE.Box3().setFromObject(table);
          table.position.y -= b1.min.y;

          // 4) подвинуть к задней стене (z = -d/2 + глубина/2 + небольшой зазор)
          const size1 = b1.getSize(new THREE.Vector3());
          const depth = size1.z;
          const wallZ = -d/2 + (depth/2) + 0.02;   // зазор 2 см, чтобы не «влипало»
          table.position.z = wallZ;

          // 5) по центру под зеркалом (x = 0), вдоль стены (ось X)
          table.position.x = 0;
          table.rotation.y = 0; // вдоль задней стены, длинной стороной по X

          fixMaterials(table);
          scene.add(table);
        }, undefined, e=>console.warn('Не удалось загрузить стол:', e));

        // (Балки можно оставить как у тебя в рабочем «старом» index; чтобы ничего не ломать я их тут не трогаю)

        // safety-resolve (если какие-то ассеты висят, всё равно закроем портал)
        setTimeout(()=>resolve(), 12000);
      });
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
