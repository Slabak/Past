<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Комната прошлого — warm + tub + dust</title>
  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; background: #000; }
    #overlay {
      position: fixed; inset: 0; display: grid; place-items: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: white; background: radial-gradient(ellipse at center, rgba(0,0,0,.65), rgba(0,0,0,.9));
      z-index: 9999;
    }
    #overlay button {
      font-size: 16px; padding: 12px 18px; border-radius: 10px; border: none; cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="overlay"><button id="start">Войти в комнату</button></div>

  <!-- Ожидается наличие этих файлов в репозитории -->
  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>
  <script src="assets/js/DRACOLoader.js"></script>
  <script>
    let scene, camera, renderer, controls, listener, sound;
    let candle1, candle2, shaft1, shaft2, dust;

    const init = () => {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x120a07);
      scene.fog = new THREE.Fog(0x1a0f0a, 8, 22);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
      camera.position.set(0, 1.6, 3);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.9;
      document.body.appendChild(renderer.domElement);

      // Controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.2, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Warm lights
      scene.add(new THREE.HemisphereLight(0xffddbb, 0x2a1a10, 0.35));
      const warmAmbient = new THREE.AmbientLight(0xffe6cc, 0.25);
      scene.add(warmAmbient);
      candle1 = new THREE.PointLight(0xffb366, 0.9, 12);
      candle1.position.set(1.2, 1.6, -1.2);
      candle1.castShadow = true;
      scene.add(candle1);
      candle2 = new THREE.PointLight(0xffa060, 0.6, 10);
      candle2.position.set(-1.4, 1.3, 1.0);
      scene.add(candle2);

      // Textures
      const tl = new THREE.TextureLoader();
      const floorTex = tl.load('assets/textures/floor.jpg');
      const wallTex  = tl.load('assets/textures/wall.jpg');
      const mirrorTex = tl.load('assets/textures/mirror.jpg');
      floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
      floorTex.repeat.set(3, 3);
      wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
      wallTex.repeat.set(2, 2);

      // Materials
      const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 1, metalness: 0, side: THREE.DoubleSide });
      const wallMat  = new THREE.MeshStandardMaterial({ map: wallTex,  roughness: 1, metalness: 0, side: THREE.DoubleSide });

      // Room sizes
      const w = 10, h = 5, d = 10;

      // Floor
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(w, d), floorMat);
      floor.rotation.x = -Math.PI/2;
      floor.position.set(0, 0, 0);
      floor.receiveShadow = true;
      scene.add(floor);

      // Walls
      const wall1 = new THREE.Mesh(new THREE.PlaneGeometry(w, h), wallMat); // back
      wall1.position.set(0, h/2, -d/2);
      const wall4 = new THREE.Mesh(new THREE.PlaneGeometry(w, h), wallMat); // front
      wall4.position.set(0, h/2,  d/2);
      wall4.rotation.y = Math.PI;
      const wall2 = new THREE.Mesh(new THREE.PlaneGeometry(d, h), wallMat); // left
      wall2.position.set(-w/2, h/2, 0);
      wall2.rotation.y =  Math.PI/2;
      const wall3 = new THREE.Mesh(new THREE.PlaneGeometry(d, h), wallMat); // right
      wall3.position.set( w/2, h/2, 0);
      wall3.rotation.y = -Math.PI/2;
      [wall1, wall2, wall3, wall4].forEach(wl => { wl.receiveShadow = true; wl.castShadow = false; scene.add(wl); });

      // Mirror on back wall
      const mirror = new THREE.Mesh(
        new THREE.PlaneGeometry(1.4, 0.9),
        new THREE.MeshStandardMaterial({ map: mirrorTex, metalness: 0.85, roughness: 0.2, side: THREE.DoubleSide })
      );
      mirror.position.set(0, 1.6, -d/2 + 0.01);
      scene.add(mirror);

      // Dust particles (Points)
      const dustCount = 1200;
      const positions = new Float32Array(dustCount * 3);
      const speeds = new Float32Array(dustCount);
      for (let i = 0; i < dustCount; i++) {
        positions[i*3 + 0] = (Math.random()-0.5) * (w-1.0);
        positions[i*3 + 1] = Math.random() * (h-0.5) + 0.3;
        positions[i*3 + 2] = (Math.random()-0.5) * (d-1.0);
        speeds[i] = 0.002 + Math.random() * 0.004;
      }
      const dustGeo = new THREE.BufferGeometry();
      dustGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      dust = new THREE.Points(
        dustGeo,
        new THREE.PointsMaterial({
          size: 0.03,
          transparent: true,
          opacity: 0.5,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        })
      );
      dust.userData.speeds = speeds;
      scene.add(dust);

      // Light shafts (fake volumetric cones) above candles
      const shaftMat = new THREE.MeshBasicMaterial({
        color: 0xffb366, transparent: true, opacity: 0.12,
        depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
      });
      shaft1 = new THREE.Mesh(new THREE.ConeGeometry(0.35, 2.6, 48, 1, true), shaftMat);
      shaft1.position.copy(candle1.position).add(new THREE.Vector3(0, 0.1, 0));
      scene.add(shaft1);
      shaft2 = new THREE.Mesh(new THREE.ConeGeometry(0.3, 2.2, 48, 1, true), shaftMat.clone());
      shaft2.material.opacity = 0.10;
      shaft2.position.copy(candle2.position).add(new THREE.Vector3(0, 0.1, 0));
      scene.add(shaft2);

      // Audio
      listener = new THREE.AudioListener();
      camera.add(listener);
      sound = new THREE.Audio(listener);
      const audioLoader = new THREE.AudioLoader();
      audioLoader.load('assets/music/music.mp3', buffer => {
        sound.setBuffer(buffer);
        sound.setLoop(true);
        sound.setVolume(0.4);
      });

      // GLTF tub (user path with forward slashes for the web)
      const loader = new THREE.GLTFLoader();
      // DRACO (на случай, если модель сжатая)
      try {
        const draco = new THREE.DRACOLoader();
        draco.setDecoderPath('assets/js/draco/'); // положи decoder *.wasm/*.js сюда при необходимости
        loader.setDRACOLoader(draco);
      } catch(e) {}

      const MODEL_URL = 'assets/models/tub_model.glb';
      loader.load(MODEL_URL, (gltf) => {
        const model = gltf.scene;
        model.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });

        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);
        model.position.sub(center);

        const diag = Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
        const targetDiag = 2.2;
        const s = diag > 0 ? targetDiag / diag : 1;
        model.scale.setScalar(s);

        // Place near right wall, face center
        const wRoom = w, dRoom = d;
        const offsetFromWall = 0.6;
        model.position.set(wRoom/2 - offsetFromWall, 0, 0);
        model.rotation.y = -Math.PI/2;

        scene.add(model);
        console.log('Модель ванны загружена:', MODEL_URL);
      }, undefined, (err) => {
        console.warn('Не удалось загрузить GLB модель (проверь путь):', (err && err.message) ? err.message : err);
        try {
          fetch(MODEL_URL, { method: 'HEAD' })
            .then(r => console.log('HEAD статус для', MODEL_URL, '→', r.status))
            .catch(e => console.log('HEAD ошибка для', MODEL_URL, '→', e));
        } catch (_) {}
      });

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Loop
      let t = 0;
      const animate = () => {
        requestAnimationFrame(animate);
        t += 0.01;
        // лёгкое «мерцание» свечей и лучей
        candle1.intensity = 0.9 + Math.sin(t*3.7) * 0.06;
        candle2.intensity = 0.6 + Math.cos(t*2.9) * 0.05;
        shaft1.material.opacity = 0.11 + Math.sin(t*1.3) * 0.02;
        shaft2.material.opacity = 0.09 + Math.cos(t*1.6) * 0.02;

        // медленное движение пылинок вверх
        const pos = dust.geometry.attributes.position;
        const spd = dust.userData.speeds;
        for (let i = 0; i < pos.count; i++) {
          let y = pos.getY(i) + spd[i];
          if (y > 4.8) y = 0.3 + Math.random() * 0.5; // респавн низко
          pos.setY(i, y);
        }
        pos.needsUpdate = true;

        controls.update();
        renderer.render(scene, camera);
      };
      animate();

      // Start audio after gesture
      document.getElementById('start').addEventListener('click', async () => {
        document.getElementById('overlay').style.display = 'none';
        try {
          const ac = listener?.context;
          if (ac && ac.state === 'suspended') await ac.resume();
        } catch(e) {}
        if (sound.buffer && !sound.isPlaying) sound.play();
      }, { once: true });
    };

    window.addEventListener('load', init);
  </script>
</body>
</html>
