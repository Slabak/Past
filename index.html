<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Комната прошлого — разлом</title>

<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}

  /* Стартовая панель */
  #overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:10;
    background:radial-gradient(ellipse at center,rgba(0,0,0,.82),rgba(0,0,0,.96));color:#fff}
  .panel{display:flex;flex-direction:column;gap:14px;align-items:center;padding:22px 26px;border-radius:14px;
    background:rgba(20,10,6,.55);backdrop-filter:blur(3px);box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .title{font-size:18px;opacity:.92;text-align:center}
  .btn{cursor:pointer;border:0;border-radius:10px;padding:12px 16px;background:#6b3c1e;color:#fff;font-weight:600}
  .btn.secondary{background:#3a2a22}
  .note{font-size:12px;opacity:.75;text-align:center;max-width:380px}

  /* Кольцевой прогресс (общая загрузка ассетов ДО входа) */
  #loading{position:fixed;inset:0;display:none;place-items:center;z-index:12;
    background:radial-gradient(ellipse at center,rgba(0,0,0,.8),rgba(0,0,0,.95));color:#fff}
  .loadbox{display:flex;flex-direction:column;align-items:center;gap:12px}
  .ring{width:110px;height:110px;border-radius:50%;
    background:conic-gradient(#ffb366 var(--p,0%), rgba(255,255,255,.08) 0);
    -webkit-mask:radial-gradient(circle at center, transparent 58%, #000 60%);
    mask:radial-gradient(circle at center, transparent 58%, #000 60%);
    box-shadow:0 0 0 1px rgba(255,255,255,.1) inset}
  .percent{font:18px/1.1 monospace}
  .hint{font:14px;opacity:.85}

  /* Портальный оверлей (во время входа/выхода VR) */
  #portalOverlay{
    position:fixed; inset:0; display:none;
    align-items:center; justify-content:center;
    background:#000; z-index:99999; opacity:0;
  }
  #portalOverlay.show{ display:flex; animation:portalFadeIn .25s ease forwards; }
  #portalOverlay.hide{ animation:portalFadeOut .5s ease forwards; }
  #portalOverlay .msg{
    color:#f3e6cf; text-align:center; line-height:1.5;
    max-width:90vw; font-size:18px;
    text-shadow:0 1px 6px rgba(0,0,0,.6);
  }
  .pulse{ animation:pulse 1.2s ease-in-out infinite; }
  @keyframes portalFadeIn{ from{opacity:0} to{opacity:1} }
  @keyframes portalFadeOut{ from{opacity:1} to{opacity:0} }
  @keyframes pulse{ 0%{opacity:.35} 50%{opacity:1} 100%{opacity:.35} }

  canvas.fade-in{animation:fi .5s ease forwards}@keyframes fi{from{opacity:0}to{opacity:1}}
</style>
</head>
<body>
  <!-- Стартовая панель -->
  <div id="overlay">
    <div class="panel">
      <div class="title">Перед тобой разлом. Готов войти?</div>
      <button class="btn" id="btn-vr">Войти в разлом</button>
      <button class="btn secondary" id="btn-flat">Смотреть со стороны</button>
      <div class="note">Если гарнитура VR недоступна, можно наблюдать «со стороны» — и всё равно услышать шёпот прошлого.</div>
    </div>
  </div>

  <!-- Общая загрузка при обычном входе -->
  <div id="loading">
    <div class="loadbox">
      <div class="ring" id="ring" style="--p:0%"></div>
      <div class="percent" id="pct">0%</div>
      <div class="hint">Материя собирается…</div>
    </div>
  </div>

  <!-- Портальный затемняющий оверлей (для VR входа/выхода) -->
  <div id="portalOverlay">
    <div class="msg pulse">Материя формируется… удерживайте связь с реальностью… 0%</div>
  </div>

  <!-- three.js -->
  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>

<script>
(() => {
  let scene, camera, renderer, controls;
  let listener, music;
  let controller1=null, controller2=null;

  // размеры комнаты (м)
  const W=4, D=4, H=3;

  // ------- портальный UI --------
  const portalUI = (() => {
    const el = document.getElementById('portalOverlay');
    const msg = el.querySelector('.msg');
    return {
      ensureShown(text){
        if(text) msg.textContent=text;
        el.classList.remove('hide'); el.style.display='flex';
        el.classList.add('show');
      },
      setProgress(p){
        const pct = Math.max(0, Math.min(1, p));
        msg.textContent = `Материя формируется… удерживайте связь с реальностью… ${Math.round(pct*100)}%`;
      },
      hideNow(){ el.style.display='none'; el.style.opacity='0'; el.classList.remove('show','hide'); },
      hide(){
        el.classList.remove('show'); el.classList.add('hide');
        setTimeout(()=>this.hideNow(),520);
      }
    };
  })();

  // ------- общий менеджер загрузки ассетов --------
  const manager = new THREE.LoadingManager();
  manager.onStart = () => {
    // если это VR-вход – уже показан порталOverlay
    // если обычный – покажем #loading
    if (!isVrPlanned) {
      document.getElementById('loading').style.display='grid';
      updateRing(0);
    } else {
      portalUI.ensureShown();
      portalUI.setProgress(0);
    }
  };
  manager.onProgress = (url, loaded, total) => {
    const prog = total ? loaded/total : 0.95;
    if (!isVrPlanned) {
      updateRing(prog);
    } else {
      portalUI.setProgress(prog);
    }
  };
  manager.onLoad = () => {
    if (!isVrPlanned) {
      setTimeout(()=>document.getElementById('loading').style.display='none',150);
    } else {
      // дадим кадр на сборку сцены
      setTimeout(()=>portalUI.hide(),350);
    }
  };
  function updateRing(p){ 
    const ring=document.getElementById('ring'); const pct=document.getElementById('pct');
    ring.style.setProperty('--p', Math.round(p*100) + '%'); pct.textContent = Math.round(p*100) + '%';
  }

  // ------- аудио -------
  function safeMusicStart(){
    try{
      const ctx = listener?.context;
      if (ctx && ctx.state==='suspended') ctx.resume();
      const loader = new THREE.AudioLoader();
      loader.load('assets/music/music.mp3', (buffer)=>{
        music.setBuffer(buffer);
        music.setLoop(true);
        music.setVolume(0.30);
        music.play();
      });
    }catch(e){ console.warn('Audio error',e); }
  }

  // ------- сцена --------
  const texLoader = new THREE.TextureLoader(manager);
  const gltfLoader = new THREE.GLTFLoader(manager);

  let isVrPlanned = false;

  // UI кнопки
  document.getElementById('btn-flat').addEventListener('click', ()=>{
    document.getElementById('overlay').style.display='none';
    isVrPlanned = false;
    init();
  });

  document.getElementById('btn-vr').addEventListener('click', async ()=>{
    // Пойдём сразу в VR: затемняем экран заранее
    isVrPlanned = true;
    portalUI.ensureShown();
    init(async ()=>{
      // как только рендерер готов — запрашиваем XR-сессию
      try{
        const session = await navigator.xr.requestSession('immersive-vr',{ requiredFeatures:['local-floor'] });
        await renderer.xr.setSession(session);
      }catch(e){
        console.warn('XR error', e);
        portalUI.hide(); // просто уйдём из затемнения, если XR не дался
      }
    });
  });

  function init(readyCb){
    // базовые
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c0705);
    scene.fog = new THREE.Fog(0x140b08, 6, 16);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.05, 50);
    camera.position.set(0, 1.6, 2.8);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    document.body.appendChild(renderer.domElement);
    renderer.domElement.classList.add('fade-in');

    // controls (для «со стороны»)
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0,1.25,0);

    // XR
    renderer.xr.enabled = true;
    setupXRControllers();

    // свет — тёплый мягкий
    const hemi = new THREE.HemisphereLight(0xffe4bd, 0x0e0906, 0.35); scene.add(hemi);
    const ambient = new THREE.AmbientLight(0xffd7aa, 0.18); scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffb366, 1.15);
    sun.position.set(-2.4, 3.7, 1.6);
    sun.castShadow = true; sun.shadow.mapSize.set(2048,2048); sun.shadow.radius = 6;
    scene.add(sun);
    const flame = new THREE.PointLight(0xffa860, 0.7, 7);
    flame.position.set(-1.5, 1.2, 1.2); scene.add(flame);

    // плоскости/текстуры
    const floorTex = texLoader.load('assets/textures/floor.jpg'); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2); floorTex.colorSpace=THREE.SRGBColorSpace;
    const wallTex = texLoader.load('assets/textures/wall.jpg?v=3'); wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping; wallTex.colorSpace=THREE.SRGBColorSpace;
    const ceilTex = texLoader.load('assets/textures/potolok.jpg'); ceilTex.wrapS=ceilTex.wrapT=THREE.RepeatWrapping; ceilTex.repeat.set(2,2); ceilTex.colorSpace=THREE.SRGBColorSpace;
    const mirrorTex = texLoader.load('assets/textures/mirror.jpg'); mirrorTex.colorSpace=THREE.SRGBColorSpace;

    // пол
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), new THREE.MeshStandardMaterial({map:floorTex, roughness:.9}));
    floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor);

    // стены (без тайлинга)
    const wallMat = new THREE.MeshStandardMaterial({map:wallTex, roughness:1.0});
    const back  = new THREE.Mesh(new THREE.PlaneGeometry(W, H), wallMat); back.position.set(0,H/2,-D/2);
    const front = new THREE.Mesh(new THREE.PlaneGeometry(W, H), wallMat); front.position.set(0,H/2, D/2); front.rotation.y=Math.PI;
    const left  = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat); left.position.set(-W/2,H/2,0);  left.rotation.y=Math.PI/2;
    const right = new THREE.Mesh(new THREE.PlaneGeometry(D, H), wallMat); right.position.set( W/2,H/2,0);  right.rotation.y=-Math.PI/2;
    [back,front,left,right].forEach(w=>w.receiveShadow=true);
    scene.add(back,front,left,right);

    // «зеркало» на задней стене (для акцента)
    const mirror = new THREE.Mesh(new THREE.PlaneGeometry(0.92,0.62),
      new THREE.MeshStandardMaterial({map:mirrorTex, metalness:.85, roughness:.22}));
    mirror.position.set(-1.2, 1.25, -D/2 + 0.01);
    scene.add(mirror);

    // аудио
    listener = new THREE.AudioListener(); camera.add(listener);
    music = new THREE.Audio(listener);

    // ------- загрузка моделей -------
    // сундук (обновлённый), «лицом» в комнату возле левой стены
    loadGLB('assets/models/chest.glb', (obj)=>{
      basicBake(obj);
      placeOnFloor(obj);
      obj.rotation.y = Math.PI; // развёрнут в комнату
      obj.position.set(-1.35, 0, -1.15);
      scene.add(obj);
    });

    // бочка — у правой стены ближе к зеркалу
    loadGLB('assets/models/barrel.glb', (obj)=>{
      basicBake(obj);
      placeOnFloor(obj);
      obj.scale.multiplyScalar(0.9);
      obj.position.set( 1.65, 0, -0.95);
      scene.add(obj);
    });

    // стол + книга
    loadGLB('assets/models/table.glb', (obj)=>{
      basicBake(obj);
      placeOnFloor(obj);
      obj.position.set(0.15,0,-0.6);
      obj.rotation.y = -0.08;
      scene.add(obj);
    });

    // скамейка — чуть отодвинута от стола
    loadGLB('assets/models/bench.glb', (obj)=>{
      basicBake(obj);
      placeOnFloor(obj);
      obj.position.set(0.05,0,-0.15);
      obj.rotation.y = -0.08;
      scene.add(obj);
    });

    // глобус — справа от стола
    loadGLB('assets/models/globus.glb', (obj)=>{
      basicBake(obj);
      placeOnFloor(obj);
      obj.position.set(1.15,0,-0.25);
      obj.rotation.y = 0.25;
      scene.add(obj);
    });

    // щит — над глобусом, чуть правее центра правой стены
    loadGLB('assets/models/shield.glb', (obj)=>{
      basicBake(obj);
      obj.scale.multiplyScalar(0.8);
      obj.rotation.y = -Math.PI/2;
      obj.position.set(W/2 - 0.01, 1.5, -0.2);
      scene.add(obj);
    });

    // дверь — на задней стене по центру, утоплена
    loadGLB('assets/models/door.glb', (obj)=>{
      basicBake(obj);
      placeOnFloor(obj);
      obj.rotation.y = 0; // плоскостью к комнате
      obj.position.set(0,0,-D/2 + 0.02); // «утоплена» в стену
      scene.add(obj);
    });

    // события
    window.addEventListener('resize', onResize);
    document.addEventListener('click', () => safeMusicStart(), { once:true });

    // старт рендера
    if(typeof readyCb === 'function') readyCb();

    renderer.setAnimationLoop(()=>{
      // «дыхание» огня
      flame.intensity = 0.55 + Math.sin(performance.now()*0.003)*0.15;
      controls.update();
      renderer.render(scene, camera);
    });
  }

  // ------- helpers -------
  function onResize(){
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }

  function basicBake(root){
    root.traverse(o=>{
      if(o.isMesh){
        o.castShadow = true;
        o.receiveShadow = true;
        if(o.material && o.material.map) o.material.map.colorSpace = THREE.SRGBColorSpace;
      }
    });
  }
  function placeOnFloor(root){
    const b = new THREE.Box3().setFromObject(root);
    root.position.y -= b.min.y; // основание на y=0
  }
  function loadGLB(path, onReady){
    gltfLoader.load(path, (g)=>onReady(g.scene), undefined, (e)=>console.warn('GLB err', path, e));
  }

  // ---------- XR контроллеры + выход ----------
  function setupXRControllers(){
    // контроллеры (если XR будет)
    controller1 = renderer.xr.getController(0);
    controller2 = renderer.xr.getController(1);
    if(controller1) scene.add(controller1);
    if(controller2) scene.add(controller2);

    // «долгое» нажатие курка для выхода
    const HOLD_MS = 1200;
    let t1=null, t2=null;

    function vibrate(ctrl, ms=200, amp=0.6){
      try{
        const gp = ctrl && ctrl.gamepad;
        if(!gp) return;
        // разные реализации в браузерах:
        if (gp.hapticActuators && gp.hapticActuators[0]){
          gp.hapticActuators[0].pulse(amp, ms);
        } else if (gp.vibrationActuator && gp.vibrationActuator.playEffect){
          gp.vibrationActuator.playEffect('dual-rumble', {
            duration: ms, strongMagnitude: amp, weakMagnitude: amp
          });
        }
      }catch(e){}
    }

    function beginHold(i){
      return ()=>{ (i===1? t1 : t2) = performance.now(); };
    }
    function endHold(i){
      return ()=>{
        const t0 = (i===1? t1 : t2); (i===1? t1 : t2) = null;
        if(!t0) return;
        if (performance.now() - t0 >= HOLD_MS){
          // вибрация обоих, затем плавный выход
          vibrate(controller1, 220, 0.8);
          vibrate(controller2, 220, 0.8);
          portalUI.ensureShown('Разрыв связи… сохраняйте тишину…');
          const s = renderer.xr.getSession?.();
          if (s){
            s.addEventListener('end', ()=>{
              document.getElementById('overlay').style.display='grid';
              portalUI.hide();
            }, { once:true });
            s.end();
          } else {
            portalUI.hide();
          }
        }
      };
    }

    if (controller1){
      controller1.addEventListener('selectstart', beginHold(1));
      controller1.addEventListener('selectend',   endHold(1));
    }
    if (controller2){
      controller2.addEventListener('selectstart', beginHold(2));
      controller2.addEventListener('selectend',   endHold(2));
    }
  }
})();
</script>
</body>
</html>
