<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Комната — стабильная и быстрая</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  #overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:5;
    background:radial-gradient(ellipse at center,rgba(0,0,0,.78),rgba(0,0,0,.95));
    color:#fff;font:16px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #overlay button{padding:12px 18px;border:none;border-radius:10px;background:#ffb366;color:#000;cursor:pointer}
  #loading{position:fixed;inset:0;display:none;place-items:center;z-index:6;color:#fff;font:14px system-ui}
  .bar{width:260px;height:8px;background:rgba(255,255,255,.12);border-radius:8px;overflow:hidden;margin-top:10px}
  .fill{height:100%;width:0;background:#ffb366;transition:width .15s}
  .vr-btn{position:fixed;left:12px;bottom:12px;z-index:7;background:#1e1e1e;color:#fff;border:1px solid #444;border-radius:8px;padding:10px 14px;font:14px system-ui;cursor:pointer}
  .vr-btn[disabled]{opacity:.4;cursor:not-allowed}
</style>
</head>
<body>
  <div id="overlay">
    <div style="text-align:center">
      <div style="margin-bottom:12px;font-size:18px">Переносимся через портал…</div>
      <button id="enter">Войти</button>
      <div style="margin-top:10px;font-size:12px;opacity:.7">Экран и VR (Quest) поддерживаются</div>
    </div>
  </div>
  <div id="loading">
    <div>
      <div id="ld-text" style="text-align:center">Загрузка… <span id="pc">0%</span></div>
      <div class="bar"><div id="fill" class="fill"></div></div>
    </div>
  </div>

  <script src="assets/js/three.min.js"></script>
  <script src="assets/js/OrbitControls.js"></script>
  <script src="assets/js/GLTFLoader.js"></script>
<script>
/* ===== Встроенная простая VR-кнопка ===== */
function createSimpleVRButton(renderer){
  const btn=document.createElement('button'); btn.className='vr-btn'; btn.textContent='Войти в VR';
  if(!('xr' in navigator)){ btn.textContent='VR не поддерживается'; btn.disabled=true; return btn; }
  let session=null;
  async function onEnd(){ session.removeEventListener('end', onEnd); session=null; btn.textContent='Войти в VR'; }
  async function onStart(s){ session=s; s.addEventListener('end', onEnd); await renderer.xr.setSession(s); btn.textContent='Выйти из VR'; }
  btn.addEventListener('click', async ()=>{
    try{
      if(!session){
        const s=await navigator.xr.requestSession('immersive-vr',{requiredFeatures:['local-floor']});
        onStart(s);
      } else { await session.end(); }
    }catch(e){ console.warn('XR error',e); }
  });
  return btn;
}

/* ===== Константы / пути ===== */
const W=4, D=4, H=3; // размеры комнаты (м)
const TEX_FLOOR='assets/textures/floor.jpg';
const TEX_WALL ='assets/textures/wall.jpg';
const TEX_CEIL ='assets/textures/potolok.jpg';
const MODEL_TABLE ='assets/models/table.glb';
const MODEL_BARREL='assets/models/barrel.glb';
const MODEL_DOOR  ='assets/models/door.glb';
const MODEL_GLOBUS='assets/models/globus.glb'; // ты его кидал — вернул

/* ===== Позиции ===== */
const POS_TABLE  = new THREE.Vector3( 0.0, 0.0, -D/2 + 0.55);    // под «зеркалом»
const POS_BARREL = new THREE.Vector3(-W/2 + 0.65, 0.0,  1.10);   // левая стена, ближе к игроку
const POS_GLOBUS = new THREE.Vector3( W/2 - 0.55, 0.0, -D/2 + 0.9); // правая стена у задней
const POS_DOOR   = new THREE.Vector3( 0.0, 0.0,  D/2 - 0.005);   // вплотную к передней стене

/* ===== Глобальные ===== */
let scene,camera,renderer,controls,loopRunning=false;

/* ===== Инициализация ===== */
function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x0b0706);
  scene.fog=new THREE.Fog(0x120b08,6,14);

  camera=new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.05, 100);
  camera.position.set(0,1.6,2.8);

  renderer=new THREE.WebGLRenderer({antialias:true});
  // Быстрее на мобилках/VR:
  const isMobile=/Android|iPhone|iPad|iPod|Quest|Oculus/i.test(navigator.userAgent);
  renderer.setPixelRatio(isMobile? 1 : Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputColorSpace=THREE.SRGBColorSpace;
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=1.05;
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.PCFSoftShadowMap;
  // Чуть скромнее карта теней — быстрее:
  renderer.shadowMap.autoUpdate=true;

  renderer.xr.enabled=true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(createSimpleVRButton(renderer));

  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.target.set(0,1.2,0);
  controls.enableDamping=true;
  controls.enablePan=false;
  controls.enableZoom=false;
  controls.rotateSpeed=-0.8;
  controls.dampingFactor=0.12;

  // Свет
  scene.add(new THREE.HemisphereLight(0xffdcb8,0x1b0e0a,0.38));
  scene.add(new THREE.AmbientLight(0xffe0bb,0.2));
  const dir=new THREE.DirectionalLight(0xffb06a,1.05);
  dir.position.set(-2.5,3.2,1.5);
  dir.castShadow=true; dir.shadow.mapSize.set(1024,1024); dir.shadow.radius=4;
  scene.add(dir);
  const fire=new THREE.PointLight(0xffa860,0.58,5.0); fire.position.set(-1.4,1.15,1.1); scene.add(fire);

  buildRoom();

  addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);
  });

  if(!loopRunning){
    loopRunning=true;
    renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene,camera); });
  }

  document.getElementById('enter').addEventListener('click',()=>{
    document.getElementById('overlay').style.display='none';
    startLoad();
  },{once:true});
}

/* ===== Комната и загрузка ===== */
function startLoad(){
  const loading=document.getElementById('loading');
  const pc=document.getElementById('pc');
  const fill=document.getElementById('fill');
  loading.style.display='grid';

  const mgr=new THREE.LoadingManager(()=>{
    // готово
    fill.style.width='100%'; pc.textContent='100%';
    setTimeout(()=>loading.style.display='none',200);
  },(_,loaded,total)=>{
    const p=Math.max(0,Math.min(100, Math.round(loaded/Math.max(1,total)*100)));
    pc.textContent=p+'%'; fill.style.width=p+'%';
  });

  loadModels(mgr);
}

function buildRoom(){
  const tl=new THREE.TextureLoader();
  // Текстуры грузим сразу (без менеджера), они лёгкие:
  const floorTex=tl.load(TEX_FLOOR); floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping; floorTex.repeat.set(2,2); floorTex.colorSpace=THREE.SRGBColorSpace;
  const wallTex =tl.load(TEX_WALL ); wallTex.wrapS=wallTex.wrapT=THREE.ClampToEdgeWrapping; wallTex.colorSpace=THREE.SRGBColorSpace;
  const ceilTex =tl.load(TEX_CEIL ); ceilTex.wrapS=ceilTex.wrapT=THREE.RepeatWrapping; ceilTex.repeat.set(2,2); ceilTex.colorSpace=THREE.SRGBColorSpace;

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:floorTex,roughness:.9}));
  floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

  const wallMat=new THREE.MeshStandardMaterial({map:wallTex,roughness:1});
  const back =new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); back.position.set(0,H/2,-D/2); scene.add(back);
  const front=new THREE.Mesh(new THREE.PlaneGeometry(W,H), wallMat); front.position.set(0,H/2, D/2); front.rotation.y=Math.PI; scene.add(front);
  const left =new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); left.position.set(-W/2,H/2,0); left.rotation.y= Math.PI/2; scene.add(left);
  const right=new THREE.Mesh(new THREE.PlaneGeometry(D,H), wallMat); right.position.set( W/2,H/2,0); right.rotation.y=-Math.PI/2; scene.add(right);

  const ceil=new THREE.Mesh(new THREE.PlaneGeometry(W,D), new THREE.MeshStandardMaterial({map:ceilTex,roughness:.85}));
  ceil.position.set(0,H,0); ceil.rotation.x=Math.PI/2; scene.add(ceil);

  // БАЛКИ — процедурно (без GLB, чтобы не тормозить)
  addBeams();
}

/* ===== Процедурные балки (быстро) ===== */
function addBeams(){
  const TH=0.22; // толщина
  const Y=H-TH/2; // высота для горизонтальных
  const wood=new THREE.MeshStandardMaterial({color:0x9b6b3a, roughness:.75, metalness:0});
  // вертикальные 4 стойки
  const postGeo=new THREE.BoxGeometry(TH, H-0.02, TH);
  const posts=[
    [-W/2+TH/2, (H-0.02)/2, -D/2+TH/2],
    [ W/2-TH/2, (H-0.02)/2, -D/2+TH/2],
    [-W/2+TH/2, (H-0.02)/2,  D/2-TH/2],
    [ W/2-TH/2, (H-0.02)/2,  D/2-TH/2],
  ];
  posts.forEach(p=>{ const m=new THREE.Mesh(postGeo, wood); m.position.set(...p); m.castShadow=false; m.receiveShadow=false; scene.add(m); });
  // горизонтальные 4 по периметру
  const hzX=new THREE.BoxGeometry(W-TH*2, TH, TH);   // зад/перед
  const hzZ=new THREE.BoxGeometry(TH, TH, D-TH*2);   // лево/право
  const hz=[
    [0, Y, -D/2+TH/2, hzX], // задняя
    [0, Y,  D/2-TH/2, hzX], // передняя
    [-W/2+TH/2, Y, 0, hzZ], // левая
    [ W/2-TH/2, Y, 0, hzZ], // правая
  ];
  hz.forEach(([x,y,z,g])=>{ const m=new THREE.Mesh(g, wood); m.position.set(x,y,z); m.castShadow=false; m.receiveShadow=false; scene.add(m); });
}

/* ===== Загрузка моделей с предсказуемыми размерами ===== */
function loadModels(manager){
  const L=new THREE.GLTFLoader(manager);

  // helper: нормализация по ВЫСОТЕ, не по диагонали — стабильнее
  function fitByHeight(root, targetH){
    root.traverse(o=>{ if(o.isMesh){o.castShadow=o.receiveShadow=true; }});
    const b=new THREE.Box3().setFromObject(root);
    const h=b.getSize(new THREE.Vector3()).y||1;
    const k=targetH/h;
    root.scale.setScalar(k);
    const b2=new THREE.Box3().setFromObject(root);
    root.position.sub(b2.getCenter(new THREE.Vector3()));
    const b3=new THREE.Box3().setFromObject(root);
    root.position.y -= b3.min.y; // на пол
  }

  // СТОЛ ~ 0.78 м
  L.load(MODEL_TABLE,(g)=>{
    const m=g.scene; fitByHeight(m, 0.78);
    m.position.copy(POS_TABLE);
    scene.add(m);
  });

  // БОЧКА ~ 1.0 м
  L.load(MODEL_BARREL,(g)=>{
    const m=g.scene; fitByHeight(m, 1.00);
    m.position.copy(POS_BARREL);
    m.rotation.y=Math.PI*0.5;
    scene.add(m);
  });

  // ГЛОБУС ~ 1.2 м
  L.load(MODEL_GLOBUS,(g)=>{
    const m=g.scene; fitByHeight(m, 1.20);
    m.position.copy(POS_GLOBUS);
    m.rotation.y=-Math.PI/2;
    scene.add(m);
  });

  // ДВЕРЬ ~ 2.1 м, строго в плоскости стены
  L.load(MODEL_DOOR,(g)=>{
    const m=g.scene; fitByHeight(m, 2.10);
    m.rotation.y=Math.PI;
    m.position.copy(POS_DOOR); // уже вплотную (−0.005)
    scene.add(m);
  });
}

/* ===== Старт ===== */
window.addEventListener('load', init);
</script>
</body>
</html>
